//@AUTOHEADER@BEGIN@
/**********************************************************************\
|                          ShoutIRC RadioBot                           |
|           Copyright 2004-2020 Drift Solutions / Indy Sams            |
|        More information available at https://www.shoutirc.com        |
|                                                                      |
|                    This file is part of RadioBot.                    |
|                                                                      |
|   RadioBot is free software: you can redistribute it and/or modify   |
| it under the terms of the GNU General Public License as published by |
|  the Free Software Foundation, either version 3 of the License, or   |
|                 (at your option) any later version.                  |
|                                                                      |
|     RadioBot is distributed in the hope that it will be useful,      |
|    but WITHOUT ANY WARRANTY; without even the implied warranty of    |
|     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the     |
|             GNU General Public License for more details.             |
|                                                                      |
|  You should have received a copy of the GNU General Public License   |
|  along with RadioBot. If not, see <https://www.gnu.org/licenses/>.   |
\**********************************************************************/
//@AUTOHEADER@END@

// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: Mumble.proto

#ifndef PROTOBUF_INCLUDED_Mumble_2eproto
#define PROTOBUF_INCLUDED_Mumble_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3007000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3007000 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_Mumble_2eproto

// Internal implementation detail -- do not use these members.
struct TableStruct_Mumble_2eproto {
  static const ::google::protobuf::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::google::protobuf::internal::ParseTable schema[32]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors_Mumble_2eproto();
namespace MumbleProto {
class ACL;
class ACLDefaultTypeInternal;
extern ACLDefaultTypeInternal _ACL_default_instance_;
class ACL_ChanACL;
class ACL_ChanACLDefaultTypeInternal;
extern ACL_ChanACLDefaultTypeInternal _ACL_ChanACL_default_instance_;
class ACL_ChanGroup;
class ACL_ChanGroupDefaultTypeInternal;
extern ACL_ChanGroupDefaultTypeInternal _ACL_ChanGroup_default_instance_;
class Authenticate;
class AuthenticateDefaultTypeInternal;
extern AuthenticateDefaultTypeInternal _Authenticate_default_instance_;
class BanList;
class BanListDefaultTypeInternal;
extern BanListDefaultTypeInternal _BanList_default_instance_;
class BanList_BanEntry;
class BanList_BanEntryDefaultTypeInternal;
extern BanList_BanEntryDefaultTypeInternal _BanList_BanEntry_default_instance_;
class ChannelRemove;
class ChannelRemoveDefaultTypeInternal;
extern ChannelRemoveDefaultTypeInternal _ChannelRemove_default_instance_;
class ChannelState;
class ChannelStateDefaultTypeInternal;
extern ChannelStateDefaultTypeInternal _ChannelState_default_instance_;
class CodecVersion;
class CodecVersionDefaultTypeInternal;
extern CodecVersionDefaultTypeInternal _CodecVersion_default_instance_;
class ContextAction;
class ContextActionDefaultTypeInternal;
extern ContextActionDefaultTypeInternal _ContextAction_default_instance_;
class ContextActionModify;
class ContextActionModifyDefaultTypeInternal;
extern ContextActionModifyDefaultTypeInternal _ContextActionModify_default_instance_;
class CryptSetup;
class CryptSetupDefaultTypeInternal;
extern CryptSetupDefaultTypeInternal _CryptSetup_default_instance_;
class PermissionDenied;
class PermissionDeniedDefaultTypeInternal;
extern PermissionDeniedDefaultTypeInternal _PermissionDenied_default_instance_;
class PermissionQuery;
class PermissionQueryDefaultTypeInternal;
extern PermissionQueryDefaultTypeInternal _PermissionQuery_default_instance_;
class Ping;
class PingDefaultTypeInternal;
extern PingDefaultTypeInternal _Ping_default_instance_;
class QueryUsers;
class QueryUsersDefaultTypeInternal;
extern QueryUsersDefaultTypeInternal _QueryUsers_default_instance_;
class Reject;
class RejectDefaultTypeInternal;
extern RejectDefaultTypeInternal _Reject_default_instance_;
class RequestBlob;
class RequestBlobDefaultTypeInternal;
extern RequestBlobDefaultTypeInternal _RequestBlob_default_instance_;
class ServerConfig;
class ServerConfigDefaultTypeInternal;
extern ServerConfigDefaultTypeInternal _ServerConfig_default_instance_;
class ServerSync;
class ServerSyncDefaultTypeInternal;
extern ServerSyncDefaultTypeInternal _ServerSync_default_instance_;
class SuggestConfig;
class SuggestConfigDefaultTypeInternal;
extern SuggestConfigDefaultTypeInternal _SuggestConfig_default_instance_;
class TextMessage;
class TextMessageDefaultTypeInternal;
extern TextMessageDefaultTypeInternal _TextMessage_default_instance_;
class UDPTunnel;
class UDPTunnelDefaultTypeInternal;
extern UDPTunnelDefaultTypeInternal _UDPTunnel_default_instance_;
class UserList;
class UserListDefaultTypeInternal;
extern UserListDefaultTypeInternal _UserList_default_instance_;
class UserList_User;
class UserList_UserDefaultTypeInternal;
extern UserList_UserDefaultTypeInternal _UserList_User_default_instance_;
class UserRemove;
class UserRemoveDefaultTypeInternal;
extern UserRemoveDefaultTypeInternal _UserRemove_default_instance_;
class UserState;
class UserStateDefaultTypeInternal;
extern UserStateDefaultTypeInternal _UserState_default_instance_;
class UserStats;
class UserStatsDefaultTypeInternal;
extern UserStatsDefaultTypeInternal _UserStats_default_instance_;
class UserStats_Stats;
class UserStats_StatsDefaultTypeInternal;
extern UserStats_StatsDefaultTypeInternal _UserStats_Stats_default_instance_;
class Version;
class VersionDefaultTypeInternal;
extern VersionDefaultTypeInternal _Version_default_instance_;
class VoiceTarget;
class VoiceTargetDefaultTypeInternal;
extern VoiceTargetDefaultTypeInternal _VoiceTarget_default_instance_;
class VoiceTarget_Target;
class VoiceTarget_TargetDefaultTypeInternal;
extern VoiceTarget_TargetDefaultTypeInternal _VoiceTarget_Target_default_instance_;
}  // namespace MumbleProto
namespace google {
namespace protobuf {
template<> ::MumbleProto::ACL* Arena::CreateMaybeMessage<::MumbleProto::ACL>(Arena*);
template<> ::MumbleProto::ACL_ChanACL* Arena::CreateMaybeMessage<::MumbleProto::ACL_ChanACL>(Arena*);
template<> ::MumbleProto::ACL_ChanGroup* Arena::CreateMaybeMessage<::MumbleProto::ACL_ChanGroup>(Arena*);
template<> ::MumbleProto::Authenticate* Arena::CreateMaybeMessage<::MumbleProto::Authenticate>(Arena*);
template<> ::MumbleProto::BanList* Arena::CreateMaybeMessage<::MumbleProto::BanList>(Arena*);
template<> ::MumbleProto::BanList_BanEntry* Arena::CreateMaybeMessage<::MumbleProto::BanList_BanEntry>(Arena*);
template<> ::MumbleProto::ChannelRemove* Arena::CreateMaybeMessage<::MumbleProto::ChannelRemove>(Arena*);
template<> ::MumbleProto::ChannelState* Arena::CreateMaybeMessage<::MumbleProto::ChannelState>(Arena*);
template<> ::MumbleProto::CodecVersion* Arena::CreateMaybeMessage<::MumbleProto::CodecVersion>(Arena*);
template<> ::MumbleProto::ContextAction* Arena::CreateMaybeMessage<::MumbleProto::ContextAction>(Arena*);
template<> ::MumbleProto::ContextActionModify* Arena::CreateMaybeMessage<::MumbleProto::ContextActionModify>(Arena*);
template<> ::MumbleProto::CryptSetup* Arena::CreateMaybeMessage<::MumbleProto::CryptSetup>(Arena*);
template<> ::MumbleProto::PermissionDenied* Arena::CreateMaybeMessage<::MumbleProto::PermissionDenied>(Arena*);
template<> ::MumbleProto::PermissionQuery* Arena::CreateMaybeMessage<::MumbleProto::PermissionQuery>(Arena*);
template<> ::MumbleProto::Ping* Arena::CreateMaybeMessage<::MumbleProto::Ping>(Arena*);
template<> ::MumbleProto::QueryUsers* Arena::CreateMaybeMessage<::MumbleProto::QueryUsers>(Arena*);
template<> ::MumbleProto::Reject* Arena::CreateMaybeMessage<::MumbleProto::Reject>(Arena*);
template<> ::MumbleProto::RequestBlob* Arena::CreateMaybeMessage<::MumbleProto::RequestBlob>(Arena*);
template<> ::MumbleProto::ServerConfig* Arena::CreateMaybeMessage<::MumbleProto::ServerConfig>(Arena*);
template<> ::MumbleProto::ServerSync* Arena::CreateMaybeMessage<::MumbleProto::ServerSync>(Arena*);
template<> ::MumbleProto::SuggestConfig* Arena::CreateMaybeMessage<::MumbleProto::SuggestConfig>(Arena*);
template<> ::MumbleProto::TextMessage* Arena::CreateMaybeMessage<::MumbleProto::TextMessage>(Arena*);
template<> ::MumbleProto::UDPTunnel* Arena::CreateMaybeMessage<::MumbleProto::UDPTunnel>(Arena*);
template<> ::MumbleProto::UserList* Arena::CreateMaybeMessage<::MumbleProto::UserList>(Arena*);
template<> ::MumbleProto::UserList_User* Arena::CreateMaybeMessage<::MumbleProto::UserList_User>(Arena*);
template<> ::MumbleProto::UserRemove* Arena::CreateMaybeMessage<::MumbleProto::UserRemove>(Arena*);
template<> ::MumbleProto::UserState* Arena::CreateMaybeMessage<::MumbleProto::UserState>(Arena*);
template<> ::MumbleProto::UserStats* Arena::CreateMaybeMessage<::MumbleProto::UserStats>(Arena*);
template<> ::MumbleProto::UserStats_Stats* Arena::CreateMaybeMessage<::MumbleProto::UserStats_Stats>(Arena*);
template<> ::MumbleProto::Version* Arena::CreateMaybeMessage<::MumbleProto::Version>(Arena*);
template<> ::MumbleProto::VoiceTarget* Arena::CreateMaybeMessage<::MumbleProto::VoiceTarget>(Arena*);
template<> ::MumbleProto::VoiceTarget_Target* Arena::CreateMaybeMessage<::MumbleProto::VoiceTarget_Target>(Arena*);
}  // namespace protobuf
}  // namespace google
namespace MumbleProto {

enum Reject_RejectType {
  Reject_RejectType_None = 0,
  Reject_RejectType_WrongVersion = 1,
  Reject_RejectType_InvalidUsername = 2,
  Reject_RejectType_WrongUserPW = 3,
  Reject_RejectType_WrongServerPW = 4,
  Reject_RejectType_UsernameInUse = 5,
  Reject_RejectType_ServerFull = 6,
  Reject_RejectType_NoCertificate = 7
};
bool Reject_RejectType_IsValid(int value);
const Reject_RejectType Reject_RejectType_RejectType_MIN = Reject_RejectType_None;
const Reject_RejectType Reject_RejectType_RejectType_MAX = Reject_RejectType_NoCertificate;
const int Reject_RejectType_RejectType_ARRAYSIZE = Reject_RejectType_RejectType_MAX + 1;

const ::google::protobuf::EnumDescriptor* Reject_RejectType_descriptor();
inline const ::std::string& Reject_RejectType_Name(Reject_RejectType value) {
  return ::google::protobuf::internal::NameOfEnum(
    Reject_RejectType_descriptor(), value);
}
inline bool Reject_RejectType_Parse(
    const ::std::string& name, Reject_RejectType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Reject_RejectType>(
    Reject_RejectType_descriptor(), name, value);
}
enum PermissionDenied_DenyType {
  PermissionDenied_DenyType_Text = 0,
  PermissionDenied_DenyType_Permission = 1,
  PermissionDenied_DenyType_SuperUser = 2,
  PermissionDenied_DenyType_ChannelName = 3,
  PermissionDenied_DenyType_TextTooLong = 4,
  PermissionDenied_DenyType_H9K = 5,
  PermissionDenied_DenyType_TemporaryChannel = 6,
  PermissionDenied_DenyType_MissingCertificate = 7,
  PermissionDenied_DenyType_UserName = 8,
  PermissionDenied_DenyType_ChannelFull = 9,
  PermissionDenied_DenyType_NestingLimit = 10
};
bool PermissionDenied_DenyType_IsValid(int value);
const PermissionDenied_DenyType PermissionDenied_DenyType_DenyType_MIN = PermissionDenied_DenyType_Text;
const PermissionDenied_DenyType PermissionDenied_DenyType_DenyType_MAX = PermissionDenied_DenyType_NestingLimit;
const int PermissionDenied_DenyType_DenyType_ARRAYSIZE = PermissionDenied_DenyType_DenyType_MAX + 1;

const ::google::protobuf::EnumDescriptor* PermissionDenied_DenyType_descriptor();
inline const ::std::string& PermissionDenied_DenyType_Name(PermissionDenied_DenyType value) {
  return ::google::protobuf::internal::NameOfEnum(
    PermissionDenied_DenyType_descriptor(), value);
}
inline bool PermissionDenied_DenyType_Parse(
    const ::std::string& name, PermissionDenied_DenyType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<PermissionDenied_DenyType>(
    PermissionDenied_DenyType_descriptor(), name, value);
}
enum ContextActionModify_Context {
  ContextActionModify_Context_Server = 1,
  ContextActionModify_Context_Channel = 2,
  ContextActionModify_Context_User = 4
};
bool ContextActionModify_Context_IsValid(int value);
const ContextActionModify_Context ContextActionModify_Context_Context_MIN = ContextActionModify_Context_Server;
const ContextActionModify_Context ContextActionModify_Context_Context_MAX = ContextActionModify_Context_User;
const int ContextActionModify_Context_Context_ARRAYSIZE = ContextActionModify_Context_Context_MAX + 1;

const ::google::protobuf::EnumDescriptor* ContextActionModify_Context_descriptor();
inline const ::std::string& ContextActionModify_Context_Name(ContextActionModify_Context value) {
  return ::google::protobuf::internal::NameOfEnum(
    ContextActionModify_Context_descriptor(), value);
}
inline bool ContextActionModify_Context_Parse(
    const ::std::string& name, ContextActionModify_Context* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ContextActionModify_Context>(
    ContextActionModify_Context_descriptor(), name, value);
}
enum ContextActionModify_Operation {
  ContextActionModify_Operation_Add = 0,
  ContextActionModify_Operation_Remove = 1
};
bool ContextActionModify_Operation_IsValid(int value);
const ContextActionModify_Operation ContextActionModify_Operation_Operation_MIN = ContextActionModify_Operation_Add;
const ContextActionModify_Operation ContextActionModify_Operation_Operation_MAX = ContextActionModify_Operation_Remove;
const int ContextActionModify_Operation_Operation_ARRAYSIZE = ContextActionModify_Operation_Operation_MAX + 1;

const ::google::protobuf::EnumDescriptor* ContextActionModify_Operation_descriptor();
inline const ::std::string& ContextActionModify_Operation_Name(ContextActionModify_Operation value) {
  return ::google::protobuf::internal::NameOfEnum(
    ContextActionModify_Operation_descriptor(), value);
}
inline bool ContextActionModify_Operation_Parse(
    const ::std::string& name, ContextActionModify_Operation* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ContextActionModify_Operation>(
    ContextActionModify_Operation_descriptor(), name, value);
}
// ===================================================================

class Version final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:MumbleProto.Version) */ {
 public:
  Version();
  virtual ~Version();

  Version(const Version& from);

  inline Version& operator=(const Version& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Version(Version&& from) noexcept
    : Version() {
    *this = ::std::move(from);
  }

  inline Version& operator=(Version&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const Version& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Version* internal_default_instance() {
    return reinterpret_cast<const Version*>(
               &_Version_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  void Swap(Version* other);
  friend void swap(Version& a, Version& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Version* New() const final {
    return CreateMaybeMessage<Version>(nullptr);
  }

  Version* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Version>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Version& from);
  void MergeFrom(const Version& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Version* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string release = 2;
  bool has_release() const;
  void clear_release();
  static const int kReleaseFieldNumber = 2;
  const ::std::string& release() const;
  void set_release(const ::std::string& value);
  #if LANG_CXX11
  void set_release(::std::string&& value);
  #endif
  void set_release(const char* value);
  void set_release(const char* value, size_t size);
  ::std::string* mutable_release();
  ::std::string* release_release();
  void set_allocated_release(::std::string* release);

  // optional string os = 3;
  bool has_os() const;
  void clear_os();
  static const int kOsFieldNumber = 3;
  const ::std::string& os() const;
  void set_os(const ::std::string& value);
  #if LANG_CXX11
  void set_os(::std::string&& value);
  #endif
  void set_os(const char* value);
  void set_os(const char* value, size_t size);
  ::std::string* mutable_os();
  ::std::string* release_os();
  void set_allocated_os(::std::string* os);

  // optional string os_version = 4;
  bool has_os_version() const;
  void clear_os_version();
  static const int kOsVersionFieldNumber = 4;
  const ::std::string& os_version() const;
  void set_os_version(const ::std::string& value);
  #if LANG_CXX11
  void set_os_version(::std::string&& value);
  #endif
  void set_os_version(const char* value);
  void set_os_version(const char* value, size_t size);
  ::std::string* mutable_os_version();
  ::std::string* release_os_version();
  void set_allocated_os_version(::std::string* os_version);

  // optional uint32 version = 1;
  bool has_version() const;
  void clear_version();
  static const int kVersionFieldNumber = 1;
  ::google::protobuf::uint32 version() const;
  void set_version(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:MumbleProto.Version)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr release_;
  ::google::protobuf::internal::ArenaStringPtr os_;
  ::google::protobuf::internal::ArenaStringPtr os_version_;
  ::google::protobuf::uint32 version_;
  friend struct ::TableStruct_Mumble_2eproto;
};
// -------------------------------------------------------------------

class UDPTunnel final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:MumbleProto.UDPTunnel) */ {
 public:
  UDPTunnel();
  virtual ~UDPTunnel();

  UDPTunnel(const UDPTunnel& from);

  inline UDPTunnel& operator=(const UDPTunnel& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  UDPTunnel(UDPTunnel&& from) noexcept
    : UDPTunnel() {
    *this = ::std::move(from);
  }

  inline UDPTunnel& operator=(UDPTunnel&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const UDPTunnel& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const UDPTunnel* internal_default_instance() {
    return reinterpret_cast<const UDPTunnel*>(
               &_UDPTunnel_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  void Swap(UDPTunnel* other);
  friend void swap(UDPTunnel& a, UDPTunnel& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline UDPTunnel* New() const final {
    return CreateMaybeMessage<UDPTunnel>(nullptr);
  }

  UDPTunnel* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<UDPTunnel>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const UDPTunnel& from);
  void MergeFrom(const UDPTunnel& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UDPTunnel* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bytes packet = 1;
  bool has_packet() const;
  void clear_packet();
  static const int kPacketFieldNumber = 1;
  const ::std::string& packet() const;
  void set_packet(const ::std::string& value);
  #if LANG_CXX11
  void set_packet(::std::string&& value);
  #endif
  void set_packet(const char* value);
  void set_packet(const void* value, size_t size);
  ::std::string* mutable_packet();
  ::std::string* release_packet();
  void set_allocated_packet(::std::string* packet);

  // @@protoc_insertion_point(class_scope:MumbleProto.UDPTunnel)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr packet_;
  friend struct ::TableStruct_Mumble_2eproto;
};
// -------------------------------------------------------------------

class Authenticate final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:MumbleProto.Authenticate) */ {
 public:
  Authenticate();
  virtual ~Authenticate();

  Authenticate(const Authenticate& from);

  inline Authenticate& operator=(const Authenticate& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Authenticate(Authenticate&& from) noexcept
    : Authenticate() {
    *this = ::std::move(from);
  }

  inline Authenticate& operator=(Authenticate&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const Authenticate& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Authenticate* internal_default_instance() {
    return reinterpret_cast<const Authenticate*>(
               &_Authenticate_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  void Swap(Authenticate* other);
  friend void swap(Authenticate& a, Authenticate& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Authenticate* New() const final {
    return CreateMaybeMessage<Authenticate>(nullptr);
  }

  Authenticate* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Authenticate>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Authenticate& from);
  void MergeFrom(const Authenticate& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Authenticate* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string tokens = 3;
  int tokens_size() const;
  void clear_tokens();
  static const int kTokensFieldNumber = 3;
  const ::std::string& tokens(int index) const;
  ::std::string* mutable_tokens(int index);
  void set_tokens(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_tokens(int index, ::std::string&& value);
  #endif
  void set_tokens(int index, const char* value);
  void set_tokens(int index, const char* value, size_t size);
  ::std::string* add_tokens();
  void add_tokens(const ::std::string& value);
  #if LANG_CXX11
  void add_tokens(::std::string&& value);
  #endif
  void add_tokens(const char* value);
  void add_tokens(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField<::std::string>& tokens() const;
  ::google::protobuf::RepeatedPtrField<::std::string>* mutable_tokens();

  // repeated int32 celt_versions = 4;
  int celt_versions_size() const;
  void clear_celt_versions();
  static const int kCeltVersionsFieldNumber = 4;
  ::google::protobuf::int32 celt_versions(int index) const;
  void set_celt_versions(int index, ::google::protobuf::int32 value);
  void add_celt_versions(::google::protobuf::int32 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      celt_versions() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_celt_versions();

  // optional string username = 1;
  bool has_username() const;
  void clear_username();
  static const int kUsernameFieldNumber = 1;
  const ::std::string& username() const;
  void set_username(const ::std::string& value);
  #if LANG_CXX11
  void set_username(::std::string&& value);
  #endif
  void set_username(const char* value);
  void set_username(const char* value, size_t size);
  ::std::string* mutable_username();
  ::std::string* release_username();
  void set_allocated_username(::std::string* username);

  // optional string password = 2;
  bool has_password() const;
  void clear_password();
  static const int kPasswordFieldNumber = 2;
  const ::std::string& password() const;
  void set_password(const ::std::string& value);
  #if LANG_CXX11
  void set_password(::std::string&& value);
  #endif
  void set_password(const char* value);
  void set_password(const char* value, size_t size);
  ::std::string* mutable_password();
  ::std::string* release_password();
  void set_allocated_password(::std::string* password);

  // optional bool opus = 5 [default = false];
  bool has_opus() const;
  void clear_opus();
  static const int kOpusFieldNumber = 5;
  bool opus() const;
  void set_opus(bool value);

  // @@protoc_insertion_point(class_scope:MumbleProto.Authenticate)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField<::std::string> tokens_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > celt_versions_;
  ::google::protobuf::internal::ArenaStringPtr username_;
  ::google::protobuf::internal::ArenaStringPtr password_;
  bool opus_;
  friend struct ::TableStruct_Mumble_2eproto;
};
// -------------------------------------------------------------------

class Ping final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:MumbleProto.Ping) */ {
 public:
  Ping();
  virtual ~Ping();

  Ping(const Ping& from);

  inline Ping& operator=(const Ping& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Ping(Ping&& from) noexcept
    : Ping() {
    *this = ::std::move(from);
  }

  inline Ping& operator=(Ping&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const Ping& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Ping* internal_default_instance() {
    return reinterpret_cast<const Ping*>(
               &_Ping_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  void Swap(Ping* other);
  friend void swap(Ping& a, Ping& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Ping* New() const final {
    return CreateMaybeMessage<Ping>(nullptr);
  }

  Ping* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Ping>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Ping& from);
  void MergeFrom(const Ping& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Ping* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint64 timestamp = 1;
  bool has_timestamp() const;
  void clear_timestamp();
  static const int kTimestampFieldNumber = 1;
  ::google::protobuf::uint64 timestamp() const;
  void set_timestamp(::google::protobuf::uint64 value);

  // optional uint32 good = 2;
  bool has_good() const;
  void clear_good();
  static const int kGoodFieldNumber = 2;
  ::google::protobuf::uint32 good() const;
  void set_good(::google::protobuf::uint32 value);

  // optional uint32 late = 3;
  bool has_late() const;
  void clear_late();
  static const int kLateFieldNumber = 3;
  ::google::protobuf::uint32 late() const;
  void set_late(::google::protobuf::uint32 value);

  // optional uint32 lost = 4;
  bool has_lost() const;
  void clear_lost();
  static const int kLostFieldNumber = 4;
  ::google::protobuf::uint32 lost() const;
  void set_lost(::google::protobuf::uint32 value);

  // optional uint32 resync = 5;
  bool has_resync() const;
  void clear_resync();
  static const int kResyncFieldNumber = 5;
  ::google::protobuf::uint32 resync() const;
  void set_resync(::google::protobuf::uint32 value);

  // optional uint32 udp_packets = 6;
  bool has_udp_packets() const;
  void clear_udp_packets();
  static const int kUdpPacketsFieldNumber = 6;
  ::google::protobuf::uint32 udp_packets() const;
  void set_udp_packets(::google::protobuf::uint32 value);

  // optional uint32 tcp_packets = 7;
  bool has_tcp_packets() const;
  void clear_tcp_packets();
  static const int kTcpPacketsFieldNumber = 7;
  ::google::protobuf::uint32 tcp_packets() const;
  void set_tcp_packets(::google::protobuf::uint32 value);

  // optional float udp_ping_avg = 8;
  bool has_udp_ping_avg() const;
  void clear_udp_ping_avg();
  static const int kUdpPingAvgFieldNumber = 8;
  float udp_ping_avg() const;
  void set_udp_ping_avg(float value);

  // optional float udp_ping_var = 9;
  bool has_udp_ping_var() const;
  void clear_udp_ping_var();
  static const int kUdpPingVarFieldNumber = 9;
  float udp_ping_var() const;
  void set_udp_ping_var(float value);

  // optional float tcp_ping_avg = 10;
  bool has_tcp_ping_avg() const;
  void clear_tcp_ping_avg();
  static const int kTcpPingAvgFieldNumber = 10;
  float tcp_ping_avg() const;
  void set_tcp_ping_avg(float value);

  // optional float tcp_ping_var = 11;
  bool has_tcp_ping_var() const;
  void clear_tcp_ping_var();
  static const int kTcpPingVarFieldNumber = 11;
  float tcp_ping_var() const;
  void set_tcp_ping_var(float value);

  // @@protoc_insertion_point(class_scope:MumbleProto.Ping)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint64 timestamp_;
  ::google::protobuf::uint32 good_;
  ::google::protobuf::uint32 late_;
  ::google::protobuf::uint32 lost_;
  ::google::protobuf::uint32 resync_;
  ::google::protobuf::uint32 udp_packets_;
  ::google::protobuf::uint32 tcp_packets_;
  float udp_ping_avg_;
  float udp_ping_var_;
  float tcp_ping_avg_;
  float tcp_ping_var_;
  friend struct ::TableStruct_Mumble_2eproto;
};
// -------------------------------------------------------------------

class Reject final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:MumbleProto.Reject) */ {
 public:
  Reject();
  virtual ~Reject();

  Reject(const Reject& from);

  inline Reject& operator=(const Reject& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Reject(Reject&& from) noexcept
    : Reject() {
    *this = ::std::move(from);
  }

  inline Reject& operator=(Reject&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const Reject& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Reject* internal_default_instance() {
    return reinterpret_cast<const Reject*>(
               &_Reject_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  void Swap(Reject* other);
  friend void swap(Reject& a, Reject& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Reject* New() const final {
    return CreateMaybeMessage<Reject>(nullptr);
  }

  Reject* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Reject>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Reject& from);
  void MergeFrom(const Reject& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Reject* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef Reject_RejectType RejectType;
  static const RejectType None =
    Reject_RejectType_None;
  static const RejectType WrongVersion =
    Reject_RejectType_WrongVersion;
  static const RejectType InvalidUsername =
    Reject_RejectType_InvalidUsername;
  static const RejectType WrongUserPW =
    Reject_RejectType_WrongUserPW;
  static const RejectType WrongServerPW =
    Reject_RejectType_WrongServerPW;
  static const RejectType UsernameInUse =
    Reject_RejectType_UsernameInUse;
  static const RejectType ServerFull =
    Reject_RejectType_ServerFull;
  static const RejectType NoCertificate =
    Reject_RejectType_NoCertificate;
  static inline bool RejectType_IsValid(int value) {
    return Reject_RejectType_IsValid(value);
  }
  static const RejectType RejectType_MIN =
    Reject_RejectType_RejectType_MIN;
  static const RejectType RejectType_MAX =
    Reject_RejectType_RejectType_MAX;
  static const int RejectType_ARRAYSIZE =
    Reject_RejectType_RejectType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  RejectType_descriptor() {
    return Reject_RejectType_descriptor();
  }
  static inline const ::std::string& RejectType_Name(RejectType value) {
    return Reject_RejectType_Name(value);
  }
  static inline bool RejectType_Parse(const ::std::string& name,
      RejectType* value) {
    return Reject_RejectType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional string reason = 2;
  bool has_reason() const;
  void clear_reason();
  static const int kReasonFieldNumber = 2;
  const ::std::string& reason() const;
  void set_reason(const ::std::string& value);
  #if LANG_CXX11
  void set_reason(::std::string&& value);
  #endif
  void set_reason(const char* value);
  void set_reason(const char* value, size_t size);
  ::std::string* mutable_reason();
  ::std::string* release_reason();
  void set_allocated_reason(::std::string* reason);

  // optional .MumbleProto.Reject.RejectType type = 1;
  bool has_type() const;
  void clear_type();
  static const int kTypeFieldNumber = 1;
  ::MumbleProto::Reject_RejectType type() const;
  void set_type(::MumbleProto::Reject_RejectType value);

  // @@protoc_insertion_point(class_scope:MumbleProto.Reject)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr reason_;
  int type_;
  friend struct ::TableStruct_Mumble_2eproto;
};
// -------------------------------------------------------------------

class ServerConfig final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:MumbleProto.ServerConfig) */ {
 public:
  ServerConfig();
  virtual ~ServerConfig();

  ServerConfig(const ServerConfig& from);

  inline ServerConfig& operator=(const ServerConfig& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ServerConfig(ServerConfig&& from) noexcept
    : ServerConfig() {
    *this = ::std::move(from);
  }

  inline ServerConfig& operator=(ServerConfig&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const ServerConfig& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ServerConfig* internal_default_instance() {
    return reinterpret_cast<const ServerConfig*>(
               &_ServerConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  void Swap(ServerConfig* other);
  friend void swap(ServerConfig& a, ServerConfig& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ServerConfig* New() const final {
    return CreateMaybeMessage<ServerConfig>(nullptr);
  }

  ServerConfig* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ServerConfig>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ServerConfig& from);
  void MergeFrom(const ServerConfig& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ServerConfig* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string welcome_text = 2;
  bool has_welcome_text() const;
  void clear_welcome_text();
  static const int kWelcomeTextFieldNumber = 2;
  const ::std::string& welcome_text() const;
  void set_welcome_text(const ::std::string& value);
  #if LANG_CXX11
  void set_welcome_text(::std::string&& value);
  #endif
  void set_welcome_text(const char* value);
  void set_welcome_text(const char* value, size_t size);
  ::std::string* mutable_welcome_text();
  ::std::string* release_welcome_text();
  void set_allocated_welcome_text(::std::string* welcome_text);

  // optional uint32 max_bandwidth = 1;
  bool has_max_bandwidth() const;
  void clear_max_bandwidth();
  static const int kMaxBandwidthFieldNumber = 1;
  ::google::protobuf::uint32 max_bandwidth() const;
  void set_max_bandwidth(::google::protobuf::uint32 value);

  // optional bool allow_html = 3;
  bool has_allow_html() const;
  void clear_allow_html();
  static const int kAllowHtmlFieldNumber = 3;
  bool allow_html() const;
  void set_allow_html(bool value);

  // optional uint32 message_length = 4;
  bool has_message_length() const;
  void clear_message_length();
  static const int kMessageLengthFieldNumber = 4;
  ::google::protobuf::uint32 message_length() const;
  void set_message_length(::google::protobuf::uint32 value);

  // optional uint32 image_message_length = 5;
  bool has_image_message_length() const;
  void clear_image_message_length();
  static const int kImageMessageLengthFieldNumber = 5;
  ::google::protobuf::uint32 image_message_length() const;
  void set_image_message_length(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:MumbleProto.ServerConfig)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr welcome_text_;
  ::google::protobuf::uint32 max_bandwidth_;
  bool allow_html_;
  ::google::protobuf::uint32 message_length_;
  ::google::protobuf::uint32 image_message_length_;
  friend struct ::TableStruct_Mumble_2eproto;
};
// -------------------------------------------------------------------

class ServerSync final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:MumbleProto.ServerSync) */ {
 public:
  ServerSync();
  virtual ~ServerSync();

  ServerSync(const ServerSync& from);

  inline ServerSync& operator=(const ServerSync& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ServerSync(ServerSync&& from) noexcept
    : ServerSync() {
    *this = ::std::move(from);
  }

  inline ServerSync& operator=(ServerSync&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const ServerSync& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ServerSync* internal_default_instance() {
    return reinterpret_cast<const ServerSync*>(
               &_ServerSync_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  void Swap(ServerSync* other);
  friend void swap(ServerSync& a, ServerSync& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ServerSync* New() const final {
    return CreateMaybeMessage<ServerSync>(nullptr);
  }

  ServerSync* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ServerSync>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ServerSync& from);
  void MergeFrom(const ServerSync& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ServerSync* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string welcome_text = 3;
  bool has_welcome_text() const;
  void clear_welcome_text();
  static const int kWelcomeTextFieldNumber = 3;
  const ::std::string& welcome_text() const;
  void set_welcome_text(const ::std::string& value);
  #if LANG_CXX11
  void set_welcome_text(::std::string&& value);
  #endif
  void set_welcome_text(const char* value);
  void set_welcome_text(const char* value, size_t size);
  ::std::string* mutable_welcome_text();
  ::std::string* release_welcome_text();
  void set_allocated_welcome_text(::std::string* welcome_text);

  // optional uint32 session = 1;
  bool has_session() const;
  void clear_session();
  static const int kSessionFieldNumber = 1;
  ::google::protobuf::uint32 session() const;
  void set_session(::google::protobuf::uint32 value);

  // optional uint32 max_bandwidth = 2;
  bool has_max_bandwidth() const;
  void clear_max_bandwidth();
  static const int kMaxBandwidthFieldNumber = 2;
  ::google::protobuf::uint32 max_bandwidth() const;
  void set_max_bandwidth(::google::protobuf::uint32 value);

  // optional uint64 permissions = 4;
  bool has_permissions() const;
  void clear_permissions();
  static const int kPermissionsFieldNumber = 4;
  ::google::protobuf::uint64 permissions() const;
  void set_permissions(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:MumbleProto.ServerSync)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr welcome_text_;
  ::google::protobuf::uint32 session_;
  ::google::protobuf::uint32 max_bandwidth_;
  ::google::protobuf::uint64 permissions_;
  friend struct ::TableStruct_Mumble_2eproto;
};
// -------------------------------------------------------------------

class ChannelRemove final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:MumbleProto.ChannelRemove) */ {
 public:
  ChannelRemove();
  virtual ~ChannelRemove();

  ChannelRemove(const ChannelRemove& from);

  inline ChannelRemove& operator=(const ChannelRemove& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ChannelRemove(ChannelRemove&& from) noexcept
    : ChannelRemove() {
    *this = ::std::move(from);
  }

  inline ChannelRemove& operator=(ChannelRemove&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const ChannelRemove& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ChannelRemove* internal_default_instance() {
    return reinterpret_cast<const ChannelRemove*>(
               &_ChannelRemove_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  void Swap(ChannelRemove* other);
  friend void swap(ChannelRemove& a, ChannelRemove& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ChannelRemove* New() const final {
    return CreateMaybeMessage<ChannelRemove>(nullptr);
  }

  ChannelRemove* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ChannelRemove>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ChannelRemove& from);
  void MergeFrom(const ChannelRemove& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ChannelRemove* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 channel_id = 1;
  bool has_channel_id() const;
  void clear_channel_id();
  static const int kChannelIdFieldNumber = 1;
  ::google::protobuf::uint32 channel_id() const;
  void set_channel_id(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:MumbleProto.ChannelRemove)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint32 channel_id_;
  friend struct ::TableStruct_Mumble_2eproto;
};
// -------------------------------------------------------------------

class ChannelState final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:MumbleProto.ChannelState) */ {
 public:
  ChannelState();
  virtual ~ChannelState();

  ChannelState(const ChannelState& from);

  inline ChannelState& operator=(const ChannelState& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ChannelState(ChannelState&& from) noexcept
    : ChannelState() {
    *this = ::std::move(from);
  }

  inline ChannelState& operator=(ChannelState&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const ChannelState& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ChannelState* internal_default_instance() {
    return reinterpret_cast<const ChannelState*>(
               &_ChannelState_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  void Swap(ChannelState* other);
  friend void swap(ChannelState& a, ChannelState& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ChannelState* New() const final {
    return CreateMaybeMessage<ChannelState>(nullptr);
  }

  ChannelState* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ChannelState>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ChannelState& from);
  void MergeFrom(const ChannelState& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ChannelState* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated uint32 links = 4;
  int links_size() const;
  void clear_links();
  static const int kLinksFieldNumber = 4;
  ::google::protobuf::uint32 links(int index) const;
  void set_links(int index, ::google::protobuf::uint32 value);
  void add_links(::google::protobuf::uint32 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      links() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_links();

  // repeated uint32 links_add = 6;
  int links_add_size() const;
  void clear_links_add();
  static const int kLinksAddFieldNumber = 6;
  ::google::protobuf::uint32 links_add(int index) const;
  void set_links_add(int index, ::google::protobuf::uint32 value);
  void add_links_add(::google::protobuf::uint32 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      links_add() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_links_add();

  // repeated uint32 links_remove = 7;
  int links_remove_size() const;
  void clear_links_remove();
  static const int kLinksRemoveFieldNumber = 7;
  ::google::protobuf::uint32 links_remove(int index) const;
  void set_links_remove(int index, ::google::protobuf::uint32 value);
  void add_links_remove(::google::protobuf::uint32 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      links_remove() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_links_remove();

  // optional string name = 3;
  bool has_name() const;
  void clear_name();
  static const int kNameFieldNumber = 3;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // optional string description = 5;
  bool has_description() const;
  void clear_description();
  static const int kDescriptionFieldNumber = 5;
  const ::std::string& description() const;
  void set_description(const ::std::string& value);
  #if LANG_CXX11
  void set_description(::std::string&& value);
  #endif
  void set_description(const char* value);
  void set_description(const char* value, size_t size);
  ::std::string* mutable_description();
  ::std::string* release_description();
  void set_allocated_description(::std::string* description);

  // optional bytes description_hash = 10;
  bool has_description_hash() const;
  void clear_description_hash();
  static const int kDescriptionHashFieldNumber = 10;
  const ::std::string& description_hash() const;
  void set_description_hash(const ::std::string& value);
  #if LANG_CXX11
  void set_description_hash(::std::string&& value);
  #endif
  void set_description_hash(const char* value);
  void set_description_hash(const void* value, size_t size);
  ::std::string* mutable_description_hash();
  ::std::string* release_description_hash();
  void set_allocated_description_hash(::std::string* description_hash);

  // optional uint32 channel_id = 1;
  bool has_channel_id() const;
  void clear_channel_id();
  static const int kChannelIdFieldNumber = 1;
  ::google::protobuf::uint32 channel_id() const;
  void set_channel_id(::google::protobuf::uint32 value);

  // optional uint32 parent = 2;
  bool has_parent() const;
  void clear_parent();
  static const int kParentFieldNumber = 2;
  ::google::protobuf::uint32 parent() const;
  void set_parent(::google::protobuf::uint32 value);

  // optional bool temporary = 8 [default = false];
  bool has_temporary() const;
  void clear_temporary();
  static const int kTemporaryFieldNumber = 8;
  bool temporary() const;
  void set_temporary(bool value);

  // optional int32 position = 9 [default = 0];
  bool has_position() const;
  void clear_position();
  static const int kPositionFieldNumber = 9;
  ::google::protobuf::int32 position() const;
  void set_position(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:MumbleProto.ChannelState)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > links_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > links_add_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > links_remove_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::internal::ArenaStringPtr description_;
  ::google::protobuf::internal::ArenaStringPtr description_hash_;
  ::google::protobuf::uint32 channel_id_;
  ::google::protobuf::uint32 parent_;
  bool temporary_;
  ::google::protobuf::int32 position_;
  friend struct ::TableStruct_Mumble_2eproto;
};
// -------------------------------------------------------------------

class UserRemove final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:MumbleProto.UserRemove) */ {
 public:
  UserRemove();
  virtual ~UserRemove();

  UserRemove(const UserRemove& from);

  inline UserRemove& operator=(const UserRemove& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  UserRemove(UserRemove&& from) noexcept
    : UserRemove() {
    *this = ::std::move(from);
  }

  inline UserRemove& operator=(UserRemove&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const UserRemove& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const UserRemove* internal_default_instance() {
    return reinterpret_cast<const UserRemove*>(
               &_UserRemove_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  void Swap(UserRemove* other);
  friend void swap(UserRemove& a, UserRemove& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline UserRemove* New() const final {
    return CreateMaybeMessage<UserRemove>(nullptr);
  }

  UserRemove* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<UserRemove>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const UserRemove& from);
  void MergeFrom(const UserRemove& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UserRemove* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string reason = 3;
  bool has_reason() const;
  void clear_reason();
  static const int kReasonFieldNumber = 3;
  const ::std::string& reason() const;
  void set_reason(const ::std::string& value);
  #if LANG_CXX11
  void set_reason(::std::string&& value);
  #endif
  void set_reason(const char* value);
  void set_reason(const char* value, size_t size);
  ::std::string* mutable_reason();
  ::std::string* release_reason();
  void set_allocated_reason(::std::string* reason);

  // required uint32 session = 1;
  bool has_session() const;
  void clear_session();
  static const int kSessionFieldNumber = 1;
  ::google::protobuf::uint32 session() const;
  void set_session(::google::protobuf::uint32 value);

  // optional uint32 actor = 2;
  bool has_actor() const;
  void clear_actor();
  static const int kActorFieldNumber = 2;
  ::google::protobuf::uint32 actor() const;
  void set_actor(::google::protobuf::uint32 value);

  // optional bool ban = 4;
  bool has_ban() const;
  void clear_ban();
  static const int kBanFieldNumber = 4;
  bool ban() const;
  void set_ban(bool value);

  // @@protoc_insertion_point(class_scope:MumbleProto.UserRemove)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr reason_;
  ::google::protobuf::uint32 session_;
  ::google::protobuf::uint32 actor_;
  bool ban_;
  friend struct ::TableStruct_Mumble_2eproto;
};
// -------------------------------------------------------------------

class UserState final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:MumbleProto.UserState) */ {
 public:
  UserState();
  virtual ~UserState();

  UserState(const UserState& from);

  inline UserState& operator=(const UserState& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  UserState(UserState&& from) noexcept
    : UserState() {
    *this = ::std::move(from);
  }

  inline UserState& operator=(UserState&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const UserState& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const UserState* internal_default_instance() {
    return reinterpret_cast<const UserState*>(
               &_UserState_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  void Swap(UserState* other);
  friend void swap(UserState& a, UserState& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline UserState* New() const final {
    return CreateMaybeMessage<UserState>(nullptr);
  }

  UserState* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<UserState>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const UserState& from);
  void MergeFrom(const UserState& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UserState* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string name = 3;
  bool has_name() const;
  void clear_name();
  static const int kNameFieldNumber = 3;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // optional bytes texture = 11;
  bool has_texture() const;
  void clear_texture();
  static const int kTextureFieldNumber = 11;
  const ::std::string& texture() const;
  void set_texture(const ::std::string& value);
  #if LANG_CXX11
  void set_texture(::std::string&& value);
  #endif
  void set_texture(const char* value);
  void set_texture(const void* value, size_t size);
  ::std::string* mutable_texture();
  ::std::string* release_texture();
  void set_allocated_texture(::std::string* texture);

  // optional bytes plugin_context = 12;
  bool has_plugin_context() const;
  void clear_plugin_context();
  static const int kPluginContextFieldNumber = 12;
  const ::std::string& plugin_context() const;
  void set_plugin_context(const ::std::string& value);
  #if LANG_CXX11
  void set_plugin_context(::std::string&& value);
  #endif
  void set_plugin_context(const char* value);
  void set_plugin_context(const void* value, size_t size);
  ::std::string* mutable_plugin_context();
  ::std::string* release_plugin_context();
  void set_allocated_plugin_context(::std::string* plugin_context);

  // optional string plugin_identity = 13;
  bool has_plugin_identity() const;
  void clear_plugin_identity();
  static const int kPluginIdentityFieldNumber = 13;
  const ::std::string& plugin_identity() const;
  void set_plugin_identity(const ::std::string& value);
  #if LANG_CXX11
  void set_plugin_identity(::std::string&& value);
  #endif
  void set_plugin_identity(const char* value);
  void set_plugin_identity(const char* value, size_t size);
  ::std::string* mutable_plugin_identity();
  ::std::string* release_plugin_identity();
  void set_allocated_plugin_identity(::std::string* plugin_identity);

  // optional string comment = 14;
  bool has_comment() const;
  void clear_comment();
  static const int kCommentFieldNumber = 14;
  const ::std::string& comment() const;
  void set_comment(const ::std::string& value);
  #if LANG_CXX11
  void set_comment(::std::string&& value);
  #endif
  void set_comment(const char* value);
  void set_comment(const char* value, size_t size);
  ::std::string* mutable_comment();
  ::std::string* release_comment();
  void set_allocated_comment(::std::string* comment);

  // optional string hash = 15;
  bool has_hash() const;
  void clear_hash();
  static const int kHashFieldNumber = 15;
  const ::std::string& hash() const;
  void set_hash(const ::std::string& value);
  #if LANG_CXX11
  void set_hash(::std::string&& value);
  #endif
  void set_hash(const char* value);
  void set_hash(const char* value, size_t size);
  ::std::string* mutable_hash();
  ::std::string* release_hash();
  void set_allocated_hash(::std::string* hash);

  // optional bytes comment_hash = 16;
  bool has_comment_hash() const;
  void clear_comment_hash();
  static const int kCommentHashFieldNumber = 16;
  const ::std::string& comment_hash() const;
  void set_comment_hash(const ::std::string& value);
  #if LANG_CXX11
  void set_comment_hash(::std::string&& value);
  #endif
  void set_comment_hash(const char* value);
  void set_comment_hash(const void* value, size_t size);
  ::std::string* mutable_comment_hash();
  ::std::string* release_comment_hash();
  void set_allocated_comment_hash(::std::string* comment_hash);

  // optional bytes texture_hash = 17;
  bool has_texture_hash() const;
  void clear_texture_hash();
  static const int kTextureHashFieldNumber = 17;
  const ::std::string& texture_hash() const;
  void set_texture_hash(const ::std::string& value);
  #if LANG_CXX11
  void set_texture_hash(::std::string&& value);
  #endif
  void set_texture_hash(const char* value);
  void set_texture_hash(const void* value, size_t size);
  ::std::string* mutable_texture_hash();
  ::std::string* release_texture_hash();
  void set_allocated_texture_hash(::std::string* texture_hash);

  // optional uint32 session = 1;
  bool has_session() const;
  void clear_session();
  static const int kSessionFieldNumber = 1;
  ::google::protobuf::uint32 session() const;
  void set_session(::google::protobuf::uint32 value);

  // optional uint32 actor = 2;
  bool has_actor() const;
  void clear_actor();
  static const int kActorFieldNumber = 2;
  ::google::protobuf::uint32 actor() const;
  void set_actor(::google::protobuf::uint32 value);

  // optional uint32 user_id = 4;
  bool has_user_id() const;
  void clear_user_id();
  static const int kUserIdFieldNumber = 4;
  ::google::protobuf::uint32 user_id() const;
  void set_user_id(::google::protobuf::uint32 value);

  // optional uint32 channel_id = 5;
  bool has_channel_id() const;
  void clear_channel_id();
  static const int kChannelIdFieldNumber = 5;
  ::google::protobuf::uint32 channel_id() const;
  void set_channel_id(::google::protobuf::uint32 value);

  // optional bool mute = 6;
  bool has_mute() const;
  void clear_mute();
  static const int kMuteFieldNumber = 6;
  bool mute() const;
  void set_mute(bool value);

  // optional bool deaf = 7;
  bool has_deaf() const;
  void clear_deaf();
  static const int kDeafFieldNumber = 7;
  bool deaf() const;
  void set_deaf(bool value);

  // optional bool suppress = 8;
  bool has_suppress() const;
  void clear_suppress();
  static const int kSuppressFieldNumber = 8;
  bool suppress() const;
  void set_suppress(bool value);

  // optional bool self_mute = 9;
  bool has_self_mute() const;
  void clear_self_mute();
  static const int kSelfMuteFieldNumber = 9;
  bool self_mute() const;
  void set_self_mute(bool value);

  // optional bool self_deaf = 10;
  bool has_self_deaf() const;
  void clear_self_deaf();
  static const int kSelfDeafFieldNumber = 10;
  bool self_deaf() const;
  void set_self_deaf(bool value);

  // optional bool priority_speaker = 18;
  bool has_priority_speaker() const;
  void clear_priority_speaker();
  static const int kPrioritySpeakerFieldNumber = 18;
  bool priority_speaker() const;
  void set_priority_speaker(bool value);

  // optional bool recording = 19;
  bool has_recording() const;
  void clear_recording();
  static const int kRecordingFieldNumber = 19;
  bool recording() const;
  void set_recording(bool value);

  // @@protoc_insertion_point(class_scope:MumbleProto.UserState)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::internal::ArenaStringPtr texture_;
  ::google::protobuf::internal::ArenaStringPtr plugin_context_;
  ::google::protobuf::internal::ArenaStringPtr plugin_identity_;
  ::google::protobuf::internal::ArenaStringPtr comment_;
  ::google::protobuf::internal::ArenaStringPtr hash_;
  ::google::protobuf::internal::ArenaStringPtr comment_hash_;
  ::google::protobuf::internal::ArenaStringPtr texture_hash_;
  ::google::protobuf::uint32 session_;
  ::google::protobuf::uint32 actor_;
  ::google::protobuf::uint32 user_id_;
  ::google::protobuf::uint32 channel_id_;
  bool mute_;
  bool deaf_;
  bool suppress_;
  bool self_mute_;
  bool self_deaf_;
  bool priority_speaker_;
  bool recording_;
  friend struct ::TableStruct_Mumble_2eproto;
};
// -------------------------------------------------------------------

class BanList_BanEntry final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:MumbleProto.BanList.BanEntry) */ {
 public:
  BanList_BanEntry();
  virtual ~BanList_BanEntry();

  BanList_BanEntry(const BanList_BanEntry& from);

  inline BanList_BanEntry& operator=(const BanList_BanEntry& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  BanList_BanEntry(BanList_BanEntry&& from) noexcept
    : BanList_BanEntry() {
    *this = ::std::move(from);
  }

  inline BanList_BanEntry& operator=(BanList_BanEntry&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const BanList_BanEntry& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const BanList_BanEntry* internal_default_instance() {
    return reinterpret_cast<const BanList_BanEntry*>(
               &_BanList_BanEntry_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  void Swap(BanList_BanEntry* other);
  friend void swap(BanList_BanEntry& a, BanList_BanEntry& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline BanList_BanEntry* New() const final {
    return CreateMaybeMessage<BanList_BanEntry>(nullptr);
  }

  BanList_BanEntry* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<BanList_BanEntry>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const BanList_BanEntry& from);
  void MergeFrom(const BanList_BanEntry& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BanList_BanEntry* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bytes address = 1;
  bool has_address() const;
  void clear_address();
  static const int kAddressFieldNumber = 1;
  const ::std::string& address() const;
  void set_address(const ::std::string& value);
  #if LANG_CXX11
  void set_address(::std::string&& value);
  #endif
  void set_address(const char* value);
  void set_address(const void* value, size_t size);
  ::std::string* mutable_address();
  ::std::string* release_address();
  void set_allocated_address(::std::string* address);

  // optional string name = 3;
  bool has_name() const;
  void clear_name();
  static const int kNameFieldNumber = 3;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // optional string hash = 4;
  bool has_hash() const;
  void clear_hash();
  static const int kHashFieldNumber = 4;
  const ::std::string& hash() const;
  void set_hash(const ::std::string& value);
  #if LANG_CXX11
  void set_hash(::std::string&& value);
  #endif
  void set_hash(const char* value);
  void set_hash(const char* value, size_t size);
  ::std::string* mutable_hash();
  ::std::string* release_hash();
  void set_allocated_hash(::std::string* hash);

  // optional string reason = 5;
  bool has_reason() const;
  void clear_reason();
  static const int kReasonFieldNumber = 5;
  const ::std::string& reason() const;
  void set_reason(const ::std::string& value);
  #if LANG_CXX11
  void set_reason(::std::string&& value);
  #endif
  void set_reason(const char* value);
  void set_reason(const char* value, size_t size);
  ::std::string* mutable_reason();
  ::std::string* release_reason();
  void set_allocated_reason(::std::string* reason);

  // optional string start = 6;
  bool has_start() const;
  void clear_start();
  static const int kStartFieldNumber = 6;
  const ::std::string& start() const;
  void set_start(const ::std::string& value);
  #if LANG_CXX11
  void set_start(::std::string&& value);
  #endif
  void set_start(const char* value);
  void set_start(const char* value, size_t size);
  ::std::string* mutable_start();
  ::std::string* release_start();
  void set_allocated_start(::std::string* start);

  // required uint32 mask = 2;
  bool has_mask() const;
  void clear_mask();
  static const int kMaskFieldNumber = 2;
  ::google::protobuf::uint32 mask() const;
  void set_mask(::google::protobuf::uint32 value);

  // optional uint32 duration = 7;
  bool has_duration() const;
  void clear_duration();
  static const int kDurationFieldNumber = 7;
  ::google::protobuf::uint32 duration() const;
  void set_duration(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:MumbleProto.BanList.BanEntry)
 private:
  class HasBitSetters;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr address_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::internal::ArenaStringPtr hash_;
  ::google::protobuf::internal::ArenaStringPtr reason_;
  ::google::protobuf::internal::ArenaStringPtr start_;
  ::google::protobuf::uint32 mask_;
  ::google::protobuf::uint32 duration_;
  friend struct ::TableStruct_Mumble_2eproto;
};
// -------------------------------------------------------------------

class BanList final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:MumbleProto.BanList) */ {
 public:
  BanList();
  virtual ~BanList();

  BanList(const BanList& from);

  inline BanList& operator=(const BanList& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  BanList(BanList&& from) noexcept
    : BanList() {
    *this = ::std::move(from);
  }

  inline BanList& operator=(BanList&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const BanList& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const BanList* internal_default_instance() {
    return reinterpret_cast<const BanList*>(
               &_BanList_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  void Swap(BanList* other);
  friend void swap(BanList& a, BanList& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline BanList* New() const final {
    return CreateMaybeMessage<BanList>(nullptr);
  }

  BanList* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<BanList>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const BanList& from);
  void MergeFrom(const BanList& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BanList* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef BanList_BanEntry BanEntry;

  // accessors -------------------------------------------------------

  // repeated .MumbleProto.BanList.BanEntry bans = 1;
  int bans_size() const;
  void clear_bans();
  static const int kBansFieldNumber = 1;
  ::MumbleProto::BanList_BanEntry* mutable_bans(int index);
  ::google::protobuf::RepeatedPtrField< ::MumbleProto::BanList_BanEntry >*
      mutable_bans();
  const ::MumbleProto::BanList_BanEntry& bans(int index) const;
  ::MumbleProto::BanList_BanEntry* add_bans();
  const ::google::protobuf::RepeatedPtrField< ::MumbleProto::BanList_BanEntry >&
      bans() const;

  // optional bool query = 2 [default = false];
  bool has_query() const;
  void clear_query();
  static const int kQueryFieldNumber = 2;
  bool query() const;
  void set_query(bool value);

  // @@protoc_insertion_point(class_scope:MumbleProto.BanList)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::MumbleProto::BanList_BanEntry > bans_;
  bool query_;
  friend struct ::TableStruct_Mumble_2eproto;
};
// -------------------------------------------------------------------

class TextMessage final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:MumbleProto.TextMessage) */ {
 public:
  TextMessage();
  virtual ~TextMessage();

  TextMessage(const TextMessage& from);

  inline TextMessage& operator=(const TextMessage& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  TextMessage(TextMessage&& from) noexcept
    : TextMessage() {
    *this = ::std::move(from);
  }

  inline TextMessage& operator=(TextMessage&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const TextMessage& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TextMessage* internal_default_instance() {
    return reinterpret_cast<const TextMessage*>(
               &_TextMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  void Swap(TextMessage* other);
  friend void swap(TextMessage& a, TextMessage& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TextMessage* New() const final {
    return CreateMaybeMessage<TextMessage>(nullptr);
  }

  TextMessage* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<TextMessage>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const TextMessage& from);
  void MergeFrom(const TextMessage& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TextMessage* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated uint32 session = 2;
  int session_size() const;
  void clear_session();
  static const int kSessionFieldNumber = 2;
  ::google::protobuf::uint32 session(int index) const;
  void set_session(int index, ::google::protobuf::uint32 value);
  void add_session(::google::protobuf::uint32 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      session() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_session();

  // repeated uint32 channel_id = 3;
  int channel_id_size() const;
  void clear_channel_id();
  static const int kChannelIdFieldNumber = 3;
  ::google::protobuf::uint32 channel_id(int index) const;
  void set_channel_id(int index, ::google::protobuf::uint32 value);
  void add_channel_id(::google::protobuf::uint32 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      channel_id() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_channel_id();

  // repeated uint32 tree_id = 4;
  int tree_id_size() const;
  void clear_tree_id();
  static const int kTreeIdFieldNumber = 4;
  ::google::protobuf::uint32 tree_id(int index) const;
  void set_tree_id(int index, ::google::protobuf::uint32 value);
  void add_tree_id(::google::protobuf::uint32 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      tree_id() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_tree_id();

  // required string message = 5;
  bool has_message() const;
  void clear_message();
  static const int kMessageFieldNumber = 5;
  const ::std::string& message() const;
  void set_message(const ::std::string& value);
  #if LANG_CXX11
  void set_message(::std::string&& value);
  #endif
  void set_message(const char* value);
  void set_message(const char* value, size_t size);
  ::std::string* mutable_message();
  ::std::string* release_message();
  void set_allocated_message(::std::string* message);

  // optional uint32 actor = 1;
  bool has_actor() const;
  void clear_actor();
  static const int kActorFieldNumber = 1;
  ::google::protobuf::uint32 actor() const;
  void set_actor(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:MumbleProto.TextMessage)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > session_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > channel_id_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > tree_id_;
  ::google::protobuf::internal::ArenaStringPtr message_;
  ::google::protobuf::uint32 actor_;
  friend struct ::TableStruct_Mumble_2eproto;
};
// -------------------------------------------------------------------

class PermissionDenied final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:MumbleProto.PermissionDenied) */ {
 public:
  PermissionDenied();
  virtual ~PermissionDenied();

  PermissionDenied(const PermissionDenied& from);

  inline PermissionDenied& operator=(const PermissionDenied& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  PermissionDenied(PermissionDenied&& from) noexcept
    : PermissionDenied() {
    *this = ::std::move(from);
  }

  inline PermissionDenied& operator=(PermissionDenied&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const PermissionDenied& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PermissionDenied* internal_default_instance() {
    return reinterpret_cast<const PermissionDenied*>(
               &_PermissionDenied_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  void Swap(PermissionDenied* other);
  friend void swap(PermissionDenied& a, PermissionDenied& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline PermissionDenied* New() const final {
    return CreateMaybeMessage<PermissionDenied>(nullptr);
  }

  PermissionDenied* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<PermissionDenied>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const PermissionDenied& from);
  void MergeFrom(const PermissionDenied& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PermissionDenied* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef PermissionDenied_DenyType DenyType;
  static const DenyType Text =
    PermissionDenied_DenyType_Text;
  static const DenyType Permission =
    PermissionDenied_DenyType_Permission;
  static const DenyType SuperUser =
    PermissionDenied_DenyType_SuperUser;
  static const DenyType ChannelName =
    PermissionDenied_DenyType_ChannelName;
  static const DenyType TextTooLong =
    PermissionDenied_DenyType_TextTooLong;
  static const DenyType H9K =
    PermissionDenied_DenyType_H9K;
  static const DenyType TemporaryChannel =
    PermissionDenied_DenyType_TemporaryChannel;
  static const DenyType MissingCertificate =
    PermissionDenied_DenyType_MissingCertificate;
  static const DenyType UserName =
    PermissionDenied_DenyType_UserName;
  static const DenyType ChannelFull =
    PermissionDenied_DenyType_ChannelFull;
  static const DenyType NestingLimit =
    PermissionDenied_DenyType_NestingLimit;
  static inline bool DenyType_IsValid(int value) {
    return PermissionDenied_DenyType_IsValid(value);
  }
  static const DenyType DenyType_MIN =
    PermissionDenied_DenyType_DenyType_MIN;
  static const DenyType DenyType_MAX =
    PermissionDenied_DenyType_DenyType_MAX;
  static const int DenyType_ARRAYSIZE =
    PermissionDenied_DenyType_DenyType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  DenyType_descriptor() {
    return PermissionDenied_DenyType_descriptor();
  }
  static inline const ::std::string& DenyType_Name(DenyType value) {
    return PermissionDenied_DenyType_Name(value);
  }
  static inline bool DenyType_Parse(const ::std::string& name,
      DenyType* value) {
    return PermissionDenied_DenyType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional string reason = 4;
  bool has_reason() const;
  void clear_reason();
  static const int kReasonFieldNumber = 4;
  const ::std::string& reason() const;
  void set_reason(const ::std::string& value);
  #if LANG_CXX11
  void set_reason(::std::string&& value);
  #endif
  void set_reason(const char* value);
  void set_reason(const char* value, size_t size);
  ::std::string* mutable_reason();
  ::std::string* release_reason();
  void set_allocated_reason(::std::string* reason);

  // optional string name = 6;
  bool has_name() const;
  void clear_name();
  static const int kNameFieldNumber = 6;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // optional uint32 permission = 1;
  bool has_permission() const;
  void clear_permission();
  static const int kPermissionFieldNumber = 1;
  ::google::protobuf::uint32 permission() const;
  void set_permission(::google::protobuf::uint32 value);

  // optional uint32 channel_id = 2;
  bool has_channel_id() const;
  void clear_channel_id();
  static const int kChannelIdFieldNumber = 2;
  ::google::protobuf::uint32 channel_id() const;
  void set_channel_id(::google::protobuf::uint32 value);

  // optional uint32 session = 3;
  bool has_session() const;
  void clear_session();
  static const int kSessionFieldNumber = 3;
  ::google::protobuf::uint32 session() const;
  void set_session(::google::protobuf::uint32 value);

  // optional .MumbleProto.PermissionDenied.DenyType type = 5;
  bool has_type() const;
  void clear_type();
  static const int kTypeFieldNumber = 5;
  ::MumbleProto::PermissionDenied_DenyType type() const;
  void set_type(::MumbleProto::PermissionDenied_DenyType value);

  // @@protoc_insertion_point(class_scope:MumbleProto.PermissionDenied)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr reason_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::uint32 permission_;
  ::google::protobuf::uint32 channel_id_;
  ::google::protobuf::uint32 session_;
  int type_;
  friend struct ::TableStruct_Mumble_2eproto;
};
// -------------------------------------------------------------------

class ACL_ChanGroup final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:MumbleProto.ACL.ChanGroup) */ {
 public:
  ACL_ChanGroup();
  virtual ~ACL_ChanGroup();

  ACL_ChanGroup(const ACL_ChanGroup& from);

  inline ACL_ChanGroup& operator=(const ACL_ChanGroup& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ACL_ChanGroup(ACL_ChanGroup&& from) noexcept
    : ACL_ChanGroup() {
    *this = ::std::move(from);
  }

  inline ACL_ChanGroup& operator=(ACL_ChanGroup&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const ACL_ChanGroup& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ACL_ChanGroup* internal_default_instance() {
    return reinterpret_cast<const ACL_ChanGroup*>(
               &_ACL_ChanGroup_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  void Swap(ACL_ChanGroup* other);
  friend void swap(ACL_ChanGroup& a, ACL_ChanGroup& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ACL_ChanGroup* New() const final {
    return CreateMaybeMessage<ACL_ChanGroup>(nullptr);
  }

  ACL_ChanGroup* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ACL_ChanGroup>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ACL_ChanGroup& from);
  void MergeFrom(const ACL_ChanGroup& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ACL_ChanGroup* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated uint32 add = 5;
  int add_size() const;
  void clear_add();
  static const int kAddFieldNumber = 5;
  ::google::protobuf::uint32 add(int index) const;
  void set_add(int index, ::google::protobuf::uint32 value);
  void add_add(::google::protobuf::uint32 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      add() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_add();

  // repeated uint32 remove = 6;
  int remove_size() const;
  void clear_remove();
  static const int kRemoveFieldNumber = 6;
  ::google::protobuf::uint32 remove(int index) const;
  void set_remove(int index, ::google::protobuf::uint32 value);
  void add_remove(::google::protobuf::uint32 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      remove() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_remove();

  // repeated uint32 inherited_members = 7;
  int inherited_members_size() const;
  void clear_inherited_members();
  static const int kInheritedMembersFieldNumber = 7;
  ::google::protobuf::uint32 inherited_members(int index) const;
  void set_inherited_members(int index, ::google::protobuf::uint32 value);
  void add_inherited_members(::google::protobuf::uint32 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      inherited_members() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_inherited_members();

  // required string name = 1;
  bool has_name() const;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // optional bool inherited = 2 [default = true];
  bool has_inherited() const;
  void clear_inherited();
  static const int kInheritedFieldNumber = 2;
  bool inherited() const;
  void set_inherited(bool value);

  // optional bool inherit = 3 [default = true];
  bool has_inherit() const;
  void clear_inherit();
  static const int kInheritFieldNumber = 3;
  bool inherit() const;
  void set_inherit(bool value);

  // optional bool inheritable = 4 [default = true];
  bool has_inheritable() const;
  void clear_inheritable();
  static const int kInheritableFieldNumber = 4;
  bool inheritable() const;
  void set_inheritable(bool value);

  // @@protoc_insertion_point(class_scope:MumbleProto.ACL.ChanGroup)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > add_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > remove_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > inherited_members_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  bool inherited_;
  bool inherit_;
  bool inheritable_;
  friend struct ::TableStruct_Mumble_2eproto;
};
// -------------------------------------------------------------------

class ACL_ChanACL final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:MumbleProto.ACL.ChanACL) */ {
 public:
  ACL_ChanACL();
  virtual ~ACL_ChanACL();

  ACL_ChanACL(const ACL_ChanACL& from);

  inline ACL_ChanACL& operator=(const ACL_ChanACL& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ACL_ChanACL(ACL_ChanACL&& from) noexcept
    : ACL_ChanACL() {
    *this = ::std::move(from);
  }

  inline ACL_ChanACL& operator=(ACL_ChanACL&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const ACL_ChanACL& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ACL_ChanACL* internal_default_instance() {
    return reinterpret_cast<const ACL_ChanACL*>(
               &_ACL_ChanACL_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  void Swap(ACL_ChanACL* other);
  friend void swap(ACL_ChanACL& a, ACL_ChanACL& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ACL_ChanACL* New() const final {
    return CreateMaybeMessage<ACL_ChanACL>(nullptr);
  }

  ACL_ChanACL* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ACL_ChanACL>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ACL_ChanACL& from);
  void MergeFrom(const ACL_ChanACL& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ACL_ChanACL* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string group = 5;
  bool has_group() const;
  void clear_group();
  static const int kGroupFieldNumber = 5;
  const ::std::string& group() const;
  void set_group(const ::std::string& value);
  #if LANG_CXX11
  void set_group(::std::string&& value);
  #endif
  void set_group(const char* value);
  void set_group(const char* value, size_t size);
  ::std::string* mutable_group();
  ::std::string* release_group();
  void set_allocated_group(::std::string* group);

  // optional uint32 user_id = 4;
  bool has_user_id() const;
  void clear_user_id();
  static const int kUserIdFieldNumber = 4;
  ::google::protobuf::uint32 user_id() const;
  void set_user_id(::google::protobuf::uint32 value);

  // optional uint32 grant = 6;
  bool has_grant() const;
  void clear_grant();
  static const int kGrantFieldNumber = 6;
  ::google::protobuf::uint32 grant() const;
  void set_grant(::google::protobuf::uint32 value);

  // optional uint32 deny = 7;
  bool has_deny() const;
  void clear_deny();
  static const int kDenyFieldNumber = 7;
  ::google::protobuf::uint32 deny() const;
  void set_deny(::google::protobuf::uint32 value);

  // optional bool apply_here = 1 [default = true];
  bool has_apply_here() const;
  void clear_apply_here();
  static const int kApplyHereFieldNumber = 1;
  bool apply_here() const;
  void set_apply_here(bool value);

  // optional bool apply_subs = 2 [default = true];
  bool has_apply_subs() const;
  void clear_apply_subs();
  static const int kApplySubsFieldNumber = 2;
  bool apply_subs() const;
  void set_apply_subs(bool value);

  // optional bool inherited = 3 [default = true];
  bool has_inherited() const;
  void clear_inherited();
  static const int kInheritedFieldNumber = 3;
  bool inherited() const;
  void set_inherited(bool value);

  // @@protoc_insertion_point(class_scope:MumbleProto.ACL.ChanACL)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr group_;
  ::google::protobuf::uint32 user_id_;
  ::google::protobuf::uint32 grant_;
  ::google::protobuf::uint32 deny_;
  bool apply_here_;
  bool apply_subs_;
  bool inherited_;
  friend struct ::TableStruct_Mumble_2eproto;
};
// -------------------------------------------------------------------

class ACL final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:MumbleProto.ACL) */ {
 public:
  ACL();
  virtual ~ACL();

  ACL(const ACL& from);

  inline ACL& operator=(const ACL& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ACL(ACL&& from) noexcept
    : ACL() {
    *this = ::std::move(from);
  }

  inline ACL& operator=(ACL&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const ACL& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ACL* internal_default_instance() {
    return reinterpret_cast<const ACL*>(
               &_ACL_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  void Swap(ACL* other);
  friend void swap(ACL& a, ACL& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ACL* New() const final {
    return CreateMaybeMessage<ACL>(nullptr);
  }

  ACL* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ACL>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ACL& from);
  void MergeFrom(const ACL& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ACL* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef ACL_ChanGroup ChanGroup;
  typedef ACL_ChanACL ChanACL;

  // accessors -------------------------------------------------------

  // repeated .MumbleProto.ACL.ChanGroup groups = 3;
  int groups_size() const;
  void clear_groups();
  static const int kGroupsFieldNumber = 3;
  ::MumbleProto::ACL_ChanGroup* mutable_groups(int index);
  ::google::protobuf::RepeatedPtrField< ::MumbleProto::ACL_ChanGroup >*
      mutable_groups();
  const ::MumbleProto::ACL_ChanGroup& groups(int index) const;
  ::MumbleProto::ACL_ChanGroup* add_groups();
  const ::google::protobuf::RepeatedPtrField< ::MumbleProto::ACL_ChanGroup >&
      groups() const;

  // repeated .MumbleProto.ACL.ChanACL acls = 4;
  int acls_size() const;
  void clear_acls();
  static const int kAclsFieldNumber = 4;
  ::MumbleProto::ACL_ChanACL* mutable_acls(int index);
  ::google::protobuf::RepeatedPtrField< ::MumbleProto::ACL_ChanACL >*
      mutable_acls();
  const ::MumbleProto::ACL_ChanACL& acls(int index) const;
  ::MumbleProto::ACL_ChanACL* add_acls();
  const ::google::protobuf::RepeatedPtrField< ::MumbleProto::ACL_ChanACL >&
      acls() const;

  // required uint32 channel_id = 1;
  bool has_channel_id() const;
  void clear_channel_id();
  static const int kChannelIdFieldNumber = 1;
  ::google::protobuf::uint32 channel_id() const;
  void set_channel_id(::google::protobuf::uint32 value);

  // optional bool query = 5 [default = false];
  bool has_query() const;
  void clear_query();
  static const int kQueryFieldNumber = 5;
  bool query() const;
  void set_query(bool value);

  // optional bool inherit_acls = 2 [default = true];
  bool has_inherit_acls() const;
  void clear_inherit_acls();
  static const int kInheritAclsFieldNumber = 2;
  bool inherit_acls() const;
  void set_inherit_acls(bool value);

  // @@protoc_insertion_point(class_scope:MumbleProto.ACL)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::MumbleProto::ACL_ChanGroup > groups_;
  ::google::protobuf::RepeatedPtrField< ::MumbleProto::ACL_ChanACL > acls_;
  ::google::protobuf::uint32 channel_id_;
  bool query_;
  bool inherit_acls_;
  friend struct ::TableStruct_Mumble_2eproto;
};
// -------------------------------------------------------------------

class QueryUsers final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:MumbleProto.QueryUsers) */ {
 public:
  QueryUsers();
  virtual ~QueryUsers();

  QueryUsers(const QueryUsers& from);

  inline QueryUsers& operator=(const QueryUsers& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  QueryUsers(QueryUsers&& from) noexcept
    : QueryUsers() {
    *this = ::std::move(from);
  }

  inline QueryUsers& operator=(QueryUsers&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const QueryUsers& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const QueryUsers* internal_default_instance() {
    return reinterpret_cast<const QueryUsers*>(
               &_QueryUsers_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  void Swap(QueryUsers* other);
  friend void swap(QueryUsers& a, QueryUsers& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline QueryUsers* New() const final {
    return CreateMaybeMessage<QueryUsers>(nullptr);
  }

  QueryUsers* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<QueryUsers>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const QueryUsers& from);
  void MergeFrom(const QueryUsers& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(QueryUsers* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated uint32 ids = 1;
  int ids_size() const;
  void clear_ids();
  static const int kIdsFieldNumber = 1;
  ::google::protobuf::uint32 ids(int index) const;
  void set_ids(int index, ::google::protobuf::uint32 value);
  void add_ids(::google::protobuf::uint32 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      ids() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_ids();

  // repeated string names = 2;
  int names_size() const;
  void clear_names();
  static const int kNamesFieldNumber = 2;
  const ::std::string& names(int index) const;
  ::std::string* mutable_names(int index);
  void set_names(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_names(int index, ::std::string&& value);
  #endif
  void set_names(int index, const char* value);
  void set_names(int index, const char* value, size_t size);
  ::std::string* add_names();
  void add_names(const ::std::string& value);
  #if LANG_CXX11
  void add_names(::std::string&& value);
  #endif
  void add_names(const char* value);
  void add_names(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField<::std::string>& names() const;
  ::google::protobuf::RepeatedPtrField<::std::string>* mutable_names();

  // @@protoc_insertion_point(class_scope:MumbleProto.QueryUsers)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > ids_;
  ::google::protobuf::RepeatedPtrField<::std::string> names_;
  friend struct ::TableStruct_Mumble_2eproto;
};
// -------------------------------------------------------------------

class CryptSetup final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:MumbleProto.CryptSetup) */ {
 public:
  CryptSetup();
  virtual ~CryptSetup();

  CryptSetup(const CryptSetup& from);

  inline CryptSetup& operator=(const CryptSetup& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CryptSetup(CryptSetup&& from) noexcept
    : CryptSetup() {
    *this = ::std::move(from);
  }

  inline CryptSetup& operator=(CryptSetup&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const CryptSetup& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CryptSetup* internal_default_instance() {
    return reinterpret_cast<const CryptSetup*>(
               &_CryptSetup_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  void Swap(CryptSetup* other);
  friend void swap(CryptSetup& a, CryptSetup& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CryptSetup* New() const final {
    return CreateMaybeMessage<CryptSetup>(nullptr);
  }

  CryptSetup* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CryptSetup>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const CryptSetup& from);
  void MergeFrom(const CryptSetup& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CryptSetup* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes key = 1;
  bool has_key() const;
  void clear_key();
  static const int kKeyFieldNumber = 1;
  const ::std::string& key() const;
  void set_key(const ::std::string& value);
  #if LANG_CXX11
  void set_key(::std::string&& value);
  #endif
  void set_key(const char* value);
  void set_key(const void* value, size_t size);
  ::std::string* mutable_key();
  ::std::string* release_key();
  void set_allocated_key(::std::string* key);

  // optional bytes client_nonce = 2;
  bool has_client_nonce() const;
  void clear_client_nonce();
  static const int kClientNonceFieldNumber = 2;
  const ::std::string& client_nonce() const;
  void set_client_nonce(const ::std::string& value);
  #if LANG_CXX11
  void set_client_nonce(::std::string&& value);
  #endif
  void set_client_nonce(const char* value);
  void set_client_nonce(const void* value, size_t size);
  ::std::string* mutable_client_nonce();
  ::std::string* release_client_nonce();
  void set_allocated_client_nonce(::std::string* client_nonce);

  // optional bytes server_nonce = 3;
  bool has_server_nonce() const;
  void clear_server_nonce();
  static const int kServerNonceFieldNumber = 3;
  const ::std::string& server_nonce() const;
  void set_server_nonce(const ::std::string& value);
  #if LANG_CXX11
  void set_server_nonce(::std::string&& value);
  #endif
  void set_server_nonce(const char* value);
  void set_server_nonce(const void* value, size_t size);
  ::std::string* mutable_server_nonce();
  ::std::string* release_server_nonce();
  void set_allocated_server_nonce(::std::string* server_nonce);

  // @@protoc_insertion_point(class_scope:MumbleProto.CryptSetup)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr key_;
  ::google::protobuf::internal::ArenaStringPtr client_nonce_;
  ::google::protobuf::internal::ArenaStringPtr server_nonce_;
  friend struct ::TableStruct_Mumble_2eproto;
};
// -------------------------------------------------------------------

class ContextActionModify final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:MumbleProto.ContextActionModify) */ {
 public:
  ContextActionModify();
  virtual ~ContextActionModify();

  ContextActionModify(const ContextActionModify& from);

  inline ContextActionModify& operator=(const ContextActionModify& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ContextActionModify(ContextActionModify&& from) noexcept
    : ContextActionModify() {
    *this = ::std::move(from);
  }

  inline ContextActionModify& operator=(ContextActionModify&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const ContextActionModify& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ContextActionModify* internal_default_instance() {
    return reinterpret_cast<const ContextActionModify*>(
               &_ContextActionModify_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  void Swap(ContextActionModify* other);
  friend void swap(ContextActionModify& a, ContextActionModify& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ContextActionModify* New() const final {
    return CreateMaybeMessage<ContextActionModify>(nullptr);
  }

  ContextActionModify* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ContextActionModify>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ContextActionModify& from);
  void MergeFrom(const ContextActionModify& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ContextActionModify* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef ContextActionModify_Context Context;
  static const Context Server =
    ContextActionModify_Context_Server;
  static const Context Channel =
    ContextActionModify_Context_Channel;
  static const Context User =
    ContextActionModify_Context_User;
  static inline bool Context_IsValid(int value) {
    return ContextActionModify_Context_IsValid(value);
  }
  static const Context Context_MIN =
    ContextActionModify_Context_Context_MIN;
  static const Context Context_MAX =
    ContextActionModify_Context_Context_MAX;
  static const int Context_ARRAYSIZE =
    ContextActionModify_Context_Context_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Context_descriptor() {
    return ContextActionModify_Context_descriptor();
  }
  static inline const ::std::string& Context_Name(Context value) {
    return ContextActionModify_Context_Name(value);
  }
  static inline bool Context_Parse(const ::std::string& name,
      Context* value) {
    return ContextActionModify_Context_Parse(name, value);
  }

  typedef ContextActionModify_Operation Operation;
  static const Operation Add =
    ContextActionModify_Operation_Add;
  static const Operation Remove =
    ContextActionModify_Operation_Remove;
  static inline bool Operation_IsValid(int value) {
    return ContextActionModify_Operation_IsValid(value);
  }
  static const Operation Operation_MIN =
    ContextActionModify_Operation_Operation_MIN;
  static const Operation Operation_MAX =
    ContextActionModify_Operation_Operation_MAX;
  static const int Operation_ARRAYSIZE =
    ContextActionModify_Operation_Operation_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Operation_descriptor() {
    return ContextActionModify_Operation_descriptor();
  }
  static inline const ::std::string& Operation_Name(Operation value) {
    return ContextActionModify_Operation_Name(value);
  }
  static inline bool Operation_Parse(const ::std::string& name,
      Operation* value) {
    return ContextActionModify_Operation_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required string action = 1;
  bool has_action() const;
  void clear_action();
  static const int kActionFieldNumber = 1;
  const ::std::string& action() const;
  void set_action(const ::std::string& value);
  #if LANG_CXX11
  void set_action(::std::string&& value);
  #endif
  void set_action(const char* value);
  void set_action(const char* value, size_t size);
  ::std::string* mutable_action();
  ::std::string* release_action();
  void set_allocated_action(::std::string* action);

  // optional string text = 2;
  bool has_text() const;
  void clear_text();
  static const int kTextFieldNumber = 2;
  const ::std::string& text() const;
  void set_text(const ::std::string& value);
  #if LANG_CXX11
  void set_text(::std::string&& value);
  #endif
  void set_text(const char* value);
  void set_text(const char* value, size_t size);
  ::std::string* mutable_text();
  ::std::string* release_text();
  void set_allocated_text(::std::string* text);

  // optional uint32 context = 3;
  bool has_context() const;
  void clear_context();
  static const int kContextFieldNumber = 3;
  ::google::protobuf::uint32 context() const;
  void set_context(::google::protobuf::uint32 value);

  // optional .MumbleProto.ContextActionModify.Operation operation = 4;
  bool has_operation() const;
  void clear_operation();
  static const int kOperationFieldNumber = 4;
  ::MumbleProto::ContextActionModify_Operation operation() const;
  void set_operation(::MumbleProto::ContextActionModify_Operation value);

  // @@protoc_insertion_point(class_scope:MumbleProto.ContextActionModify)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr action_;
  ::google::protobuf::internal::ArenaStringPtr text_;
  ::google::protobuf::uint32 context_;
  int operation_;
  friend struct ::TableStruct_Mumble_2eproto;
};
// -------------------------------------------------------------------

class ContextAction final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:MumbleProto.ContextAction) */ {
 public:
  ContextAction();
  virtual ~ContextAction();

  ContextAction(const ContextAction& from);

  inline ContextAction& operator=(const ContextAction& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ContextAction(ContextAction&& from) noexcept
    : ContextAction() {
    *this = ::std::move(from);
  }

  inline ContextAction& operator=(ContextAction&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const ContextAction& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ContextAction* internal_default_instance() {
    return reinterpret_cast<const ContextAction*>(
               &_ContextAction_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  void Swap(ContextAction* other);
  friend void swap(ContextAction& a, ContextAction& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ContextAction* New() const final {
    return CreateMaybeMessage<ContextAction>(nullptr);
  }

  ContextAction* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ContextAction>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ContextAction& from);
  void MergeFrom(const ContextAction& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ContextAction* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string action = 3;
  bool has_action() const;
  void clear_action();
  static const int kActionFieldNumber = 3;
  const ::std::string& action() const;
  void set_action(const ::std::string& value);
  #if LANG_CXX11
  void set_action(::std::string&& value);
  #endif
  void set_action(const char* value);
  void set_action(const char* value, size_t size);
  ::std::string* mutable_action();
  ::std::string* release_action();
  void set_allocated_action(::std::string* action);

  // optional uint32 session = 1;
  bool has_session() const;
  void clear_session();
  static const int kSessionFieldNumber = 1;
  ::google::protobuf::uint32 session() const;
  void set_session(::google::protobuf::uint32 value);

  // optional uint32 channel_id = 2;
  bool has_channel_id() const;
  void clear_channel_id();
  static const int kChannelIdFieldNumber = 2;
  ::google::protobuf::uint32 channel_id() const;
  void set_channel_id(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:MumbleProto.ContextAction)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr action_;
  ::google::protobuf::uint32 session_;
  ::google::protobuf::uint32 channel_id_;
  friend struct ::TableStruct_Mumble_2eproto;
};
// -------------------------------------------------------------------

class UserList_User final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:MumbleProto.UserList.User) */ {
 public:
  UserList_User();
  virtual ~UserList_User();

  UserList_User(const UserList_User& from);

  inline UserList_User& operator=(const UserList_User& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  UserList_User(UserList_User&& from) noexcept
    : UserList_User() {
    *this = ::std::move(from);
  }

  inline UserList_User& operator=(UserList_User&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const UserList_User& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const UserList_User* internal_default_instance() {
    return reinterpret_cast<const UserList_User*>(
               &_UserList_User_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    22;

  void Swap(UserList_User* other);
  friend void swap(UserList_User& a, UserList_User& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline UserList_User* New() const final {
    return CreateMaybeMessage<UserList_User>(nullptr);
  }

  UserList_User* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<UserList_User>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const UserList_User& from);
  void MergeFrom(const UserList_User& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UserList_User* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string name = 2;
  bool has_name() const;
  void clear_name();
  static const int kNameFieldNumber = 2;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // required uint32 user_id = 1;
  bool has_user_id() const;
  void clear_user_id();
  static const int kUserIdFieldNumber = 1;
  ::google::protobuf::uint32 user_id() const;
  void set_user_id(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:MumbleProto.UserList.User)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::uint32 user_id_;
  friend struct ::TableStruct_Mumble_2eproto;
};
// -------------------------------------------------------------------

class UserList final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:MumbleProto.UserList) */ {
 public:
  UserList();
  virtual ~UserList();

  UserList(const UserList& from);

  inline UserList& operator=(const UserList& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  UserList(UserList&& from) noexcept
    : UserList() {
    *this = ::std::move(from);
  }

  inline UserList& operator=(UserList&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const UserList& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const UserList* internal_default_instance() {
    return reinterpret_cast<const UserList*>(
               &_UserList_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    23;

  void Swap(UserList* other);
  friend void swap(UserList& a, UserList& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline UserList* New() const final {
    return CreateMaybeMessage<UserList>(nullptr);
  }

  UserList* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<UserList>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const UserList& from);
  void MergeFrom(const UserList& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UserList* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef UserList_User User;

  // accessors -------------------------------------------------------

  // repeated .MumbleProto.UserList.User users = 1;
  int users_size() const;
  void clear_users();
  static const int kUsersFieldNumber = 1;
  ::MumbleProto::UserList_User* mutable_users(int index);
  ::google::protobuf::RepeatedPtrField< ::MumbleProto::UserList_User >*
      mutable_users();
  const ::MumbleProto::UserList_User& users(int index) const;
  ::MumbleProto::UserList_User* add_users();
  const ::google::protobuf::RepeatedPtrField< ::MumbleProto::UserList_User >&
      users() const;

  // @@protoc_insertion_point(class_scope:MumbleProto.UserList)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::MumbleProto::UserList_User > users_;
  friend struct ::TableStruct_Mumble_2eproto;
};
// -------------------------------------------------------------------

class VoiceTarget_Target final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:MumbleProto.VoiceTarget.Target) */ {
 public:
  VoiceTarget_Target();
  virtual ~VoiceTarget_Target();

  VoiceTarget_Target(const VoiceTarget_Target& from);

  inline VoiceTarget_Target& operator=(const VoiceTarget_Target& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  VoiceTarget_Target(VoiceTarget_Target&& from) noexcept
    : VoiceTarget_Target() {
    *this = ::std::move(from);
  }

  inline VoiceTarget_Target& operator=(VoiceTarget_Target&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const VoiceTarget_Target& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const VoiceTarget_Target* internal_default_instance() {
    return reinterpret_cast<const VoiceTarget_Target*>(
               &_VoiceTarget_Target_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    24;

  void Swap(VoiceTarget_Target* other);
  friend void swap(VoiceTarget_Target& a, VoiceTarget_Target& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline VoiceTarget_Target* New() const final {
    return CreateMaybeMessage<VoiceTarget_Target>(nullptr);
  }

  VoiceTarget_Target* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<VoiceTarget_Target>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const VoiceTarget_Target& from);
  void MergeFrom(const VoiceTarget_Target& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(VoiceTarget_Target* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated uint32 session = 1;
  int session_size() const;
  void clear_session();
  static const int kSessionFieldNumber = 1;
  ::google::protobuf::uint32 session(int index) const;
  void set_session(int index, ::google::protobuf::uint32 value);
  void add_session(::google::protobuf::uint32 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      session() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_session();

  // optional string group = 3;
  bool has_group() const;
  void clear_group();
  static const int kGroupFieldNumber = 3;
  const ::std::string& group() const;
  void set_group(const ::std::string& value);
  #if LANG_CXX11
  void set_group(::std::string&& value);
  #endif
  void set_group(const char* value);
  void set_group(const char* value, size_t size);
  ::std::string* mutable_group();
  ::std::string* release_group();
  void set_allocated_group(::std::string* group);

  // optional uint32 channel_id = 2;
  bool has_channel_id() const;
  void clear_channel_id();
  static const int kChannelIdFieldNumber = 2;
  ::google::protobuf::uint32 channel_id() const;
  void set_channel_id(::google::protobuf::uint32 value);

  // optional bool links = 4 [default = false];
  bool has_links() const;
  void clear_links();
  static const int kLinksFieldNumber = 4;
  bool links() const;
  void set_links(bool value);

  // optional bool children = 5 [default = false];
  bool has_children() const;
  void clear_children();
  static const int kChildrenFieldNumber = 5;
  bool children() const;
  void set_children(bool value);

  // @@protoc_insertion_point(class_scope:MumbleProto.VoiceTarget.Target)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > session_;
  ::google::protobuf::internal::ArenaStringPtr group_;
  ::google::protobuf::uint32 channel_id_;
  bool links_;
  bool children_;
  friend struct ::TableStruct_Mumble_2eproto;
};
// -------------------------------------------------------------------

class VoiceTarget final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:MumbleProto.VoiceTarget) */ {
 public:
  VoiceTarget();
  virtual ~VoiceTarget();

  VoiceTarget(const VoiceTarget& from);

  inline VoiceTarget& operator=(const VoiceTarget& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  VoiceTarget(VoiceTarget&& from) noexcept
    : VoiceTarget() {
    *this = ::std::move(from);
  }

  inline VoiceTarget& operator=(VoiceTarget&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const VoiceTarget& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const VoiceTarget* internal_default_instance() {
    return reinterpret_cast<const VoiceTarget*>(
               &_VoiceTarget_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    25;

  void Swap(VoiceTarget* other);
  friend void swap(VoiceTarget& a, VoiceTarget& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline VoiceTarget* New() const final {
    return CreateMaybeMessage<VoiceTarget>(nullptr);
  }

  VoiceTarget* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<VoiceTarget>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const VoiceTarget& from);
  void MergeFrom(const VoiceTarget& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(VoiceTarget* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef VoiceTarget_Target Target;

  // accessors -------------------------------------------------------

  // repeated .MumbleProto.VoiceTarget.Target targets = 2;
  int targets_size() const;
  void clear_targets();
  static const int kTargetsFieldNumber = 2;
  ::MumbleProto::VoiceTarget_Target* mutable_targets(int index);
  ::google::protobuf::RepeatedPtrField< ::MumbleProto::VoiceTarget_Target >*
      mutable_targets();
  const ::MumbleProto::VoiceTarget_Target& targets(int index) const;
  ::MumbleProto::VoiceTarget_Target* add_targets();
  const ::google::protobuf::RepeatedPtrField< ::MumbleProto::VoiceTarget_Target >&
      targets() const;

  // optional uint32 id = 1;
  bool has_id() const;
  void clear_id();
  static const int kIdFieldNumber = 1;
  ::google::protobuf::uint32 id() const;
  void set_id(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:MumbleProto.VoiceTarget)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::MumbleProto::VoiceTarget_Target > targets_;
  ::google::protobuf::uint32 id_;
  friend struct ::TableStruct_Mumble_2eproto;
};
// -------------------------------------------------------------------

class PermissionQuery final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:MumbleProto.PermissionQuery) */ {
 public:
  PermissionQuery();
  virtual ~PermissionQuery();

  PermissionQuery(const PermissionQuery& from);

  inline PermissionQuery& operator=(const PermissionQuery& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  PermissionQuery(PermissionQuery&& from) noexcept
    : PermissionQuery() {
    *this = ::std::move(from);
  }

  inline PermissionQuery& operator=(PermissionQuery&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const PermissionQuery& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PermissionQuery* internal_default_instance() {
    return reinterpret_cast<const PermissionQuery*>(
               &_PermissionQuery_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    26;

  void Swap(PermissionQuery* other);
  friend void swap(PermissionQuery& a, PermissionQuery& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline PermissionQuery* New() const final {
    return CreateMaybeMessage<PermissionQuery>(nullptr);
  }

  PermissionQuery* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<PermissionQuery>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const PermissionQuery& from);
  void MergeFrom(const PermissionQuery& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PermissionQuery* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 channel_id = 1;
  bool has_channel_id() const;
  void clear_channel_id();
  static const int kChannelIdFieldNumber = 1;
  ::google::protobuf::uint32 channel_id() const;
  void set_channel_id(::google::protobuf::uint32 value);

  // optional uint32 permissions = 2;
  bool has_permissions() const;
  void clear_permissions();
  static const int kPermissionsFieldNumber = 2;
  ::google::protobuf::uint32 permissions() const;
  void set_permissions(::google::protobuf::uint32 value);

  // optional bool flush = 3 [default = false];
  bool has_flush() const;
  void clear_flush();
  static const int kFlushFieldNumber = 3;
  bool flush() const;
  void set_flush(bool value);

  // @@protoc_insertion_point(class_scope:MumbleProto.PermissionQuery)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint32 channel_id_;
  ::google::protobuf::uint32 permissions_;
  bool flush_;
  friend struct ::TableStruct_Mumble_2eproto;
};
// -------------------------------------------------------------------

class CodecVersion final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:MumbleProto.CodecVersion) */ {
 public:
  CodecVersion();
  virtual ~CodecVersion();

  CodecVersion(const CodecVersion& from);

  inline CodecVersion& operator=(const CodecVersion& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CodecVersion(CodecVersion&& from) noexcept
    : CodecVersion() {
    *this = ::std::move(from);
  }

  inline CodecVersion& operator=(CodecVersion&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const CodecVersion& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CodecVersion* internal_default_instance() {
    return reinterpret_cast<const CodecVersion*>(
               &_CodecVersion_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    27;

  void Swap(CodecVersion* other);
  friend void swap(CodecVersion& a, CodecVersion& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CodecVersion* New() const final {
    return CreateMaybeMessage<CodecVersion>(nullptr);
  }

  CodecVersion* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CodecVersion>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const CodecVersion& from);
  void MergeFrom(const CodecVersion& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CodecVersion* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 alpha = 1;
  bool has_alpha() const;
  void clear_alpha();
  static const int kAlphaFieldNumber = 1;
  ::google::protobuf::int32 alpha() const;
  void set_alpha(::google::protobuf::int32 value);

  // required int32 beta = 2;
  bool has_beta() const;
  void clear_beta();
  static const int kBetaFieldNumber = 2;
  ::google::protobuf::int32 beta() const;
  void set_beta(::google::protobuf::int32 value);

  // optional bool opus = 4 [default = false];
  bool has_opus() const;
  void clear_opus();
  static const int kOpusFieldNumber = 4;
  bool opus() const;
  void set_opus(bool value);

  // required bool prefer_alpha = 3 [default = true];
  bool has_prefer_alpha() const;
  void clear_prefer_alpha();
  static const int kPreferAlphaFieldNumber = 3;
  bool prefer_alpha() const;
  void set_prefer_alpha(bool value);

  // @@protoc_insertion_point(class_scope:MumbleProto.CodecVersion)
 private:
  class HasBitSetters;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::int32 alpha_;
  ::google::protobuf::int32 beta_;
  bool opus_;
  bool prefer_alpha_;
  friend struct ::TableStruct_Mumble_2eproto;
};
// -------------------------------------------------------------------

class UserStats_Stats final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:MumbleProto.UserStats.Stats) */ {
 public:
  UserStats_Stats();
  virtual ~UserStats_Stats();

  UserStats_Stats(const UserStats_Stats& from);

  inline UserStats_Stats& operator=(const UserStats_Stats& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  UserStats_Stats(UserStats_Stats&& from) noexcept
    : UserStats_Stats() {
    *this = ::std::move(from);
  }

  inline UserStats_Stats& operator=(UserStats_Stats&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const UserStats_Stats& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const UserStats_Stats* internal_default_instance() {
    return reinterpret_cast<const UserStats_Stats*>(
               &_UserStats_Stats_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    28;

  void Swap(UserStats_Stats* other);
  friend void swap(UserStats_Stats& a, UserStats_Stats& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline UserStats_Stats* New() const final {
    return CreateMaybeMessage<UserStats_Stats>(nullptr);
  }

  UserStats_Stats* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<UserStats_Stats>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const UserStats_Stats& from);
  void MergeFrom(const UserStats_Stats& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UserStats_Stats* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 good = 1;
  bool has_good() const;
  void clear_good();
  static const int kGoodFieldNumber = 1;
  ::google::protobuf::uint32 good() const;
  void set_good(::google::protobuf::uint32 value);

  // optional uint32 late = 2;
  bool has_late() const;
  void clear_late();
  static const int kLateFieldNumber = 2;
  ::google::protobuf::uint32 late() const;
  void set_late(::google::protobuf::uint32 value);

  // optional uint32 lost = 3;
  bool has_lost() const;
  void clear_lost();
  static const int kLostFieldNumber = 3;
  ::google::protobuf::uint32 lost() const;
  void set_lost(::google::protobuf::uint32 value);

  // optional uint32 resync = 4;
  bool has_resync() const;
  void clear_resync();
  static const int kResyncFieldNumber = 4;
  ::google::protobuf::uint32 resync() const;
  void set_resync(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:MumbleProto.UserStats.Stats)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint32 good_;
  ::google::protobuf::uint32 late_;
  ::google::protobuf::uint32 lost_;
  ::google::protobuf::uint32 resync_;
  friend struct ::TableStruct_Mumble_2eproto;
};
// -------------------------------------------------------------------

class UserStats final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:MumbleProto.UserStats) */ {
 public:
  UserStats();
  virtual ~UserStats();

  UserStats(const UserStats& from);

  inline UserStats& operator=(const UserStats& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  UserStats(UserStats&& from) noexcept
    : UserStats() {
    *this = ::std::move(from);
  }

  inline UserStats& operator=(UserStats&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const UserStats& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const UserStats* internal_default_instance() {
    return reinterpret_cast<const UserStats*>(
               &_UserStats_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    29;

  void Swap(UserStats* other);
  friend void swap(UserStats& a, UserStats& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline UserStats* New() const final {
    return CreateMaybeMessage<UserStats>(nullptr);
  }

  UserStats* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<UserStats>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const UserStats& from);
  void MergeFrom(const UserStats& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UserStats* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef UserStats_Stats Stats;

  // accessors -------------------------------------------------------

  // repeated bytes certificates = 3;
  int certificates_size() const;
  void clear_certificates();
  static const int kCertificatesFieldNumber = 3;
  const ::std::string& certificates(int index) const;
  ::std::string* mutable_certificates(int index);
  void set_certificates(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_certificates(int index, ::std::string&& value);
  #endif
  void set_certificates(int index, const char* value);
  void set_certificates(int index, const void* value, size_t size);
  ::std::string* add_certificates();
  void add_certificates(const ::std::string& value);
  #if LANG_CXX11
  void add_certificates(::std::string&& value);
  #endif
  void add_certificates(const char* value);
  void add_certificates(const void* value, size_t size);
  const ::google::protobuf::RepeatedPtrField<::std::string>& certificates() const;
  ::google::protobuf::RepeatedPtrField<::std::string>* mutable_certificates();

  // repeated int32 celt_versions = 13;
  int celt_versions_size() const;
  void clear_celt_versions();
  static const int kCeltVersionsFieldNumber = 13;
  ::google::protobuf::int32 celt_versions(int index) const;
  void set_celt_versions(int index, ::google::protobuf::int32 value);
  void add_celt_versions(::google::protobuf::int32 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      celt_versions() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_celt_versions();

  // optional bytes address = 14;
  bool has_address() const;
  void clear_address();
  static const int kAddressFieldNumber = 14;
  const ::std::string& address() const;
  void set_address(const ::std::string& value);
  #if LANG_CXX11
  void set_address(::std::string&& value);
  #endif
  void set_address(const char* value);
  void set_address(const void* value, size_t size);
  ::std::string* mutable_address();
  ::std::string* release_address();
  void set_allocated_address(::std::string* address);

  // optional .MumbleProto.UserStats.Stats from_client = 4;
  bool has_from_client() const;
  void clear_from_client();
  static const int kFromClientFieldNumber = 4;
  const ::MumbleProto::UserStats_Stats& from_client() const;
  ::MumbleProto::UserStats_Stats* release_from_client();
  ::MumbleProto::UserStats_Stats* mutable_from_client();
  void set_allocated_from_client(::MumbleProto::UserStats_Stats* from_client);

  // optional .MumbleProto.UserStats.Stats from_server = 5;
  bool has_from_server() const;
  void clear_from_server();
  static const int kFromServerFieldNumber = 5;
  const ::MumbleProto::UserStats_Stats& from_server() const;
  ::MumbleProto::UserStats_Stats* release_from_server();
  ::MumbleProto::UserStats_Stats* mutable_from_server();
  void set_allocated_from_server(::MumbleProto::UserStats_Stats* from_server);

  // optional .MumbleProto.Version version = 12;
  bool has_version() const;
  void clear_version();
  static const int kVersionFieldNumber = 12;
  const ::MumbleProto::Version& version() const;
  ::MumbleProto::Version* release_version();
  ::MumbleProto::Version* mutable_version();
  void set_allocated_version(::MumbleProto::Version* version);

  // optional uint32 session = 1;
  bool has_session() const;
  void clear_session();
  static const int kSessionFieldNumber = 1;
  ::google::protobuf::uint32 session() const;
  void set_session(::google::protobuf::uint32 value);

  // optional uint32 udp_packets = 6;
  bool has_udp_packets() const;
  void clear_udp_packets();
  static const int kUdpPacketsFieldNumber = 6;
  ::google::protobuf::uint32 udp_packets() const;
  void set_udp_packets(::google::protobuf::uint32 value);

  // optional uint32 tcp_packets = 7;
  bool has_tcp_packets() const;
  void clear_tcp_packets();
  static const int kTcpPacketsFieldNumber = 7;
  ::google::protobuf::uint32 tcp_packets() const;
  void set_tcp_packets(::google::protobuf::uint32 value);

  // optional float udp_ping_avg = 8;
  bool has_udp_ping_avg() const;
  void clear_udp_ping_avg();
  static const int kUdpPingAvgFieldNumber = 8;
  float udp_ping_avg() const;
  void set_udp_ping_avg(float value);

  // optional float udp_ping_var = 9;
  bool has_udp_ping_var() const;
  void clear_udp_ping_var();
  static const int kUdpPingVarFieldNumber = 9;
  float udp_ping_var() const;
  void set_udp_ping_var(float value);

  // optional float tcp_ping_avg = 10;
  bool has_tcp_ping_avg() const;
  void clear_tcp_ping_avg();
  static const int kTcpPingAvgFieldNumber = 10;
  float tcp_ping_avg() const;
  void set_tcp_ping_avg(float value);

  // optional float tcp_ping_var = 11;
  bool has_tcp_ping_var() const;
  void clear_tcp_ping_var();
  static const int kTcpPingVarFieldNumber = 11;
  float tcp_ping_var() const;
  void set_tcp_ping_var(float value);

  // optional bool stats_only = 2 [default = false];
  bool has_stats_only() const;
  void clear_stats_only();
  static const int kStatsOnlyFieldNumber = 2;
  bool stats_only() const;
  void set_stats_only(bool value);

  // optional bool strong_certificate = 18 [default = false];
  bool has_strong_certificate() const;
  void clear_strong_certificate();
  static const int kStrongCertificateFieldNumber = 18;
  bool strong_certificate() const;
  void set_strong_certificate(bool value);

  // optional bool opus = 19 [default = false];
  bool has_opus() const;
  void clear_opus();
  static const int kOpusFieldNumber = 19;
  bool opus() const;
  void set_opus(bool value);

  // optional uint32 bandwidth = 15;
  bool has_bandwidth() const;
  void clear_bandwidth();
  static const int kBandwidthFieldNumber = 15;
  ::google::protobuf::uint32 bandwidth() const;
  void set_bandwidth(::google::protobuf::uint32 value);

  // optional uint32 onlinesecs = 16;
  bool has_onlinesecs() const;
  void clear_onlinesecs();
  static const int kOnlinesecsFieldNumber = 16;
  ::google::protobuf::uint32 onlinesecs() const;
  void set_onlinesecs(::google::protobuf::uint32 value);

  // optional uint32 idlesecs = 17;
  bool has_idlesecs() const;
  void clear_idlesecs();
  static const int kIdlesecsFieldNumber = 17;
  ::google::protobuf::uint32 idlesecs() const;
  void set_idlesecs(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:MumbleProto.UserStats)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField<::std::string> certificates_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > celt_versions_;
  ::google::protobuf::internal::ArenaStringPtr address_;
  ::MumbleProto::UserStats_Stats* from_client_;
  ::MumbleProto::UserStats_Stats* from_server_;
  ::MumbleProto::Version* version_;
  ::google::protobuf::uint32 session_;
  ::google::protobuf::uint32 udp_packets_;
  ::google::protobuf::uint32 tcp_packets_;
  float udp_ping_avg_;
  float udp_ping_var_;
  float tcp_ping_avg_;
  float tcp_ping_var_;
  bool stats_only_;
  bool strong_certificate_;
  bool opus_;
  ::google::protobuf::uint32 bandwidth_;
  ::google::protobuf::uint32 onlinesecs_;
  ::google::protobuf::uint32 idlesecs_;
  friend struct ::TableStruct_Mumble_2eproto;
};
// -------------------------------------------------------------------

class SuggestConfig final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:MumbleProto.SuggestConfig) */ {
 public:
  SuggestConfig();
  virtual ~SuggestConfig();

  SuggestConfig(const SuggestConfig& from);

  inline SuggestConfig& operator=(const SuggestConfig& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SuggestConfig(SuggestConfig&& from) noexcept
    : SuggestConfig() {
    *this = ::std::move(from);
  }

  inline SuggestConfig& operator=(SuggestConfig&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const SuggestConfig& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SuggestConfig* internal_default_instance() {
    return reinterpret_cast<const SuggestConfig*>(
               &_SuggestConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    30;

  void Swap(SuggestConfig* other);
  friend void swap(SuggestConfig& a, SuggestConfig& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SuggestConfig* New() const final {
    return CreateMaybeMessage<SuggestConfig>(nullptr);
  }

  SuggestConfig* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<SuggestConfig>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const SuggestConfig& from);
  void MergeFrom(const SuggestConfig& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SuggestConfig* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 version = 1;
  bool has_version() const;
  void clear_version();
  static const int kVersionFieldNumber = 1;
  ::google::protobuf::uint32 version() const;
  void set_version(::google::protobuf::uint32 value);

  // optional bool positional = 2;
  bool has_positional() const;
  void clear_positional();
  static const int kPositionalFieldNumber = 2;
  bool positional() const;
  void set_positional(bool value);

  // optional bool push_to_talk = 3;
  bool has_push_to_talk() const;
  void clear_push_to_talk();
  static const int kPushToTalkFieldNumber = 3;
  bool push_to_talk() const;
  void set_push_to_talk(bool value);

  // @@protoc_insertion_point(class_scope:MumbleProto.SuggestConfig)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint32 version_;
  bool positional_;
  bool push_to_talk_;
  friend struct ::TableStruct_Mumble_2eproto;
};
// -------------------------------------------------------------------

class RequestBlob final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:MumbleProto.RequestBlob) */ {
 public:
  RequestBlob();
  virtual ~RequestBlob();

  RequestBlob(const RequestBlob& from);

  inline RequestBlob& operator=(const RequestBlob& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RequestBlob(RequestBlob&& from) noexcept
    : RequestBlob() {
    *this = ::std::move(from);
  }

  inline RequestBlob& operator=(RequestBlob&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const RequestBlob& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RequestBlob* internal_default_instance() {
    return reinterpret_cast<const RequestBlob*>(
               &_RequestBlob_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    31;

  void Swap(RequestBlob* other);
  friend void swap(RequestBlob& a, RequestBlob& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RequestBlob* New() const final {
    return CreateMaybeMessage<RequestBlob>(nullptr);
  }

  RequestBlob* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<RequestBlob>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const RequestBlob& from);
  void MergeFrom(const RequestBlob& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RequestBlob* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated uint32 session_texture = 1;
  int session_texture_size() const;
  void clear_session_texture();
  static const int kSessionTextureFieldNumber = 1;
  ::google::protobuf::uint32 session_texture(int index) const;
  void set_session_texture(int index, ::google::protobuf::uint32 value);
  void add_session_texture(::google::protobuf::uint32 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      session_texture() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_session_texture();

  // repeated uint32 session_comment = 2;
  int session_comment_size() const;
  void clear_session_comment();
  static const int kSessionCommentFieldNumber = 2;
  ::google::protobuf::uint32 session_comment(int index) const;
  void set_session_comment(int index, ::google::protobuf::uint32 value);
  void add_session_comment(::google::protobuf::uint32 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      session_comment() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_session_comment();

  // repeated uint32 channel_description = 3;
  int channel_description_size() const;
  void clear_channel_description();
  static const int kChannelDescriptionFieldNumber = 3;
  ::google::protobuf::uint32 channel_description(int index) const;
  void set_channel_description(int index, ::google::protobuf::uint32 value);
  void add_channel_description(::google::protobuf::uint32 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      channel_description() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_channel_description();

  // @@protoc_insertion_point(class_scope:MumbleProto.RequestBlob)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > session_texture_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > session_comment_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > channel_description_;
  friend struct ::TableStruct_Mumble_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Version

// optional uint32 version = 1;
inline bool Version::has_version() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Version::clear_version() {
  version_ = 0u;
  _has_bits_[0] &= ~0x00000008u;
}
inline ::google::protobuf::uint32 Version::version() const {
  // @@protoc_insertion_point(field_get:MumbleProto.Version.version)
  return version_;
}
inline void Version::set_version(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000008u;
  version_ = value;
  // @@protoc_insertion_point(field_set:MumbleProto.Version.version)
}

// optional string release = 2;
inline bool Version::has_release() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Version::clear_release() {
  release_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::std::string& Version::release() const {
  // @@protoc_insertion_point(field_get:MumbleProto.Version.release)
  return release_.GetNoArena();
}
inline void Version::set_release(const ::std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  release_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:MumbleProto.Version.release)
}
#if LANG_CXX11
inline void Version::set_release(::std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  release_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:MumbleProto.Version.release)
}
#endif
inline void Version::set_release(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  release_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:MumbleProto.Version.release)
}
inline void Version::set_release(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  release_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:MumbleProto.Version.release)
}
inline ::std::string* Version::mutable_release() {
  _has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_mutable:MumbleProto.Version.release)
  return release_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Version::release_release() {
  // @@protoc_insertion_point(field_release:MumbleProto.Version.release)
  if (!has_release()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return release_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Version::set_allocated_release(::std::string* release) {
  if (release != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  release_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), release);
  // @@protoc_insertion_point(field_set_allocated:MumbleProto.Version.release)
}

// optional string os = 3;
inline bool Version::has_os() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Version::clear_os() {
  os_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::std::string& Version::os() const {
  // @@protoc_insertion_point(field_get:MumbleProto.Version.os)
  return os_.GetNoArena();
}
inline void Version::set_os(const ::std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  os_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:MumbleProto.Version.os)
}
#if LANG_CXX11
inline void Version::set_os(::std::string&& value) {
  _has_bits_[0] |= 0x00000002u;
  os_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:MumbleProto.Version.os)
}
#endif
inline void Version::set_os(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000002u;
  os_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:MumbleProto.Version.os)
}
inline void Version::set_os(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000002u;
  os_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:MumbleProto.Version.os)
}
inline ::std::string* Version::mutable_os() {
  _has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_mutable:MumbleProto.Version.os)
  return os_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Version::release_os() {
  // @@protoc_insertion_point(field_release:MumbleProto.Version.os)
  if (!has_os()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return os_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Version::set_allocated_os(::std::string* os) {
  if (os != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  os_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), os);
  // @@protoc_insertion_point(field_set_allocated:MumbleProto.Version.os)
}

// optional string os_version = 4;
inline bool Version::has_os_version() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Version::clear_os_version() {
  os_version_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000004u;
}
inline const ::std::string& Version::os_version() const {
  // @@protoc_insertion_point(field_get:MumbleProto.Version.os_version)
  return os_version_.GetNoArena();
}
inline void Version::set_os_version(const ::std::string& value) {
  _has_bits_[0] |= 0x00000004u;
  os_version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:MumbleProto.Version.os_version)
}
#if LANG_CXX11
inline void Version::set_os_version(::std::string&& value) {
  _has_bits_[0] |= 0x00000004u;
  os_version_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:MumbleProto.Version.os_version)
}
#endif
inline void Version::set_os_version(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000004u;
  os_version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:MumbleProto.Version.os_version)
}
inline void Version::set_os_version(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000004u;
  os_version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:MumbleProto.Version.os_version)
}
inline ::std::string* Version::mutable_os_version() {
  _has_bits_[0] |= 0x00000004u;
  // @@protoc_insertion_point(field_mutable:MumbleProto.Version.os_version)
  return os_version_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Version::release_os_version() {
  // @@protoc_insertion_point(field_release:MumbleProto.Version.os_version)
  if (!has_os_version()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000004u;
  return os_version_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Version::set_allocated_os_version(::std::string* os_version) {
  if (os_version != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  os_version_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), os_version);
  // @@protoc_insertion_point(field_set_allocated:MumbleProto.Version.os_version)
}

// -------------------------------------------------------------------

// UDPTunnel

// required bytes packet = 1;
inline bool UDPTunnel::has_packet() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UDPTunnel::clear_packet() {
  packet_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::std::string& UDPTunnel::packet() const {
  // @@protoc_insertion_point(field_get:MumbleProto.UDPTunnel.packet)
  return packet_.GetNoArena();
}
inline void UDPTunnel::set_packet(const ::std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  packet_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:MumbleProto.UDPTunnel.packet)
}
#if LANG_CXX11
inline void UDPTunnel::set_packet(::std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  packet_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:MumbleProto.UDPTunnel.packet)
}
#endif
inline void UDPTunnel::set_packet(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  packet_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:MumbleProto.UDPTunnel.packet)
}
inline void UDPTunnel::set_packet(const void* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  packet_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:MumbleProto.UDPTunnel.packet)
}
inline ::std::string* UDPTunnel::mutable_packet() {
  _has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_mutable:MumbleProto.UDPTunnel.packet)
  return packet_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* UDPTunnel::release_packet() {
  // @@protoc_insertion_point(field_release:MumbleProto.UDPTunnel.packet)
  if (!has_packet()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return packet_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void UDPTunnel::set_allocated_packet(::std::string* packet) {
  if (packet != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  packet_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), packet);
  // @@protoc_insertion_point(field_set_allocated:MumbleProto.UDPTunnel.packet)
}

// -------------------------------------------------------------------

// Authenticate

// optional string username = 1;
inline bool Authenticate::has_username() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Authenticate::clear_username() {
  username_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::std::string& Authenticate::username() const {
  // @@protoc_insertion_point(field_get:MumbleProto.Authenticate.username)
  return username_.GetNoArena();
}
inline void Authenticate::set_username(const ::std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  username_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:MumbleProto.Authenticate.username)
}
#if LANG_CXX11
inline void Authenticate::set_username(::std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  username_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:MumbleProto.Authenticate.username)
}
#endif
inline void Authenticate::set_username(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  username_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:MumbleProto.Authenticate.username)
}
inline void Authenticate::set_username(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  username_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:MumbleProto.Authenticate.username)
}
inline ::std::string* Authenticate::mutable_username() {
  _has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_mutable:MumbleProto.Authenticate.username)
  return username_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Authenticate::release_username() {
  // @@protoc_insertion_point(field_release:MumbleProto.Authenticate.username)
  if (!has_username()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return username_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Authenticate::set_allocated_username(::std::string* username) {
  if (username != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  username_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), username);
  // @@protoc_insertion_point(field_set_allocated:MumbleProto.Authenticate.username)
}

// optional string password = 2;
inline bool Authenticate::has_password() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Authenticate::clear_password() {
  password_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::std::string& Authenticate::password() const {
  // @@protoc_insertion_point(field_get:MumbleProto.Authenticate.password)
  return password_.GetNoArena();
}
inline void Authenticate::set_password(const ::std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  password_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:MumbleProto.Authenticate.password)
}
#if LANG_CXX11
inline void Authenticate::set_password(::std::string&& value) {
  _has_bits_[0] |= 0x00000002u;
  password_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:MumbleProto.Authenticate.password)
}
#endif
inline void Authenticate::set_password(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000002u;
  password_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:MumbleProto.Authenticate.password)
}
inline void Authenticate::set_password(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000002u;
  password_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:MumbleProto.Authenticate.password)
}
inline ::std::string* Authenticate::mutable_password() {
  _has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_mutable:MumbleProto.Authenticate.password)
  return password_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Authenticate::release_password() {
  // @@protoc_insertion_point(field_release:MumbleProto.Authenticate.password)
  if (!has_password()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return password_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Authenticate::set_allocated_password(::std::string* password) {
  if (password != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  password_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), password);
  // @@protoc_insertion_point(field_set_allocated:MumbleProto.Authenticate.password)
}

// repeated string tokens = 3;
inline int Authenticate::tokens_size() const {
  return tokens_.size();
}
inline void Authenticate::clear_tokens() {
  tokens_.Clear();
}
inline const ::std::string& Authenticate::tokens(int index) const {
  // @@protoc_insertion_point(field_get:MumbleProto.Authenticate.tokens)
  return tokens_.Get(index);
}
inline ::std::string* Authenticate::mutable_tokens(int index) {
  // @@protoc_insertion_point(field_mutable:MumbleProto.Authenticate.tokens)
  return tokens_.Mutable(index);
}
inline void Authenticate::set_tokens(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:MumbleProto.Authenticate.tokens)
  tokens_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void Authenticate::set_tokens(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:MumbleProto.Authenticate.tokens)
  tokens_.Mutable(index)->assign(std::move(value));
}
#endif
inline void Authenticate::set_tokens(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  tokens_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:MumbleProto.Authenticate.tokens)
}
inline void Authenticate::set_tokens(int index, const char* value, size_t size) {
  tokens_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:MumbleProto.Authenticate.tokens)
}
inline ::std::string* Authenticate::add_tokens() {
  // @@protoc_insertion_point(field_add_mutable:MumbleProto.Authenticate.tokens)
  return tokens_.Add();
}
inline void Authenticate::add_tokens(const ::std::string& value) {
  tokens_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:MumbleProto.Authenticate.tokens)
}
#if LANG_CXX11
inline void Authenticate::add_tokens(::std::string&& value) {
  tokens_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:MumbleProto.Authenticate.tokens)
}
#endif
inline void Authenticate::add_tokens(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  tokens_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:MumbleProto.Authenticate.tokens)
}
inline void Authenticate::add_tokens(const char* value, size_t size) {
  tokens_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:MumbleProto.Authenticate.tokens)
}
inline const ::google::protobuf::RepeatedPtrField<::std::string>&
Authenticate::tokens() const {
  // @@protoc_insertion_point(field_list:MumbleProto.Authenticate.tokens)
  return tokens_;
}
inline ::google::protobuf::RepeatedPtrField<::std::string>*
Authenticate::mutable_tokens() {
  // @@protoc_insertion_point(field_mutable_list:MumbleProto.Authenticate.tokens)
  return &tokens_;
}

// repeated int32 celt_versions = 4;
inline int Authenticate::celt_versions_size() const {
  return celt_versions_.size();
}
inline void Authenticate::clear_celt_versions() {
  celt_versions_.Clear();
}
inline ::google::protobuf::int32 Authenticate::celt_versions(int index) const {
  // @@protoc_insertion_point(field_get:MumbleProto.Authenticate.celt_versions)
  return celt_versions_.Get(index);
}
inline void Authenticate::set_celt_versions(int index, ::google::protobuf::int32 value) {
  celt_versions_.Set(index, value);
  // @@protoc_insertion_point(field_set:MumbleProto.Authenticate.celt_versions)
}
inline void Authenticate::add_celt_versions(::google::protobuf::int32 value) {
  celt_versions_.Add(value);
  // @@protoc_insertion_point(field_add:MumbleProto.Authenticate.celt_versions)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
Authenticate::celt_versions() const {
  // @@protoc_insertion_point(field_list:MumbleProto.Authenticate.celt_versions)
  return celt_versions_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
Authenticate::mutable_celt_versions() {
  // @@protoc_insertion_point(field_mutable_list:MumbleProto.Authenticate.celt_versions)
  return &celt_versions_;
}

// optional bool opus = 5 [default = false];
inline bool Authenticate::has_opus() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Authenticate::clear_opus() {
  opus_ = false;
  _has_bits_[0] &= ~0x00000004u;
}
inline bool Authenticate::opus() const {
  // @@protoc_insertion_point(field_get:MumbleProto.Authenticate.opus)
  return opus_;
}
inline void Authenticate::set_opus(bool value) {
  _has_bits_[0] |= 0x00000004u;
  opus_ = value;
  // @@protoc_insertion_point(field_set:MumbleProto.Authenticate.opus)
}

// -------------------------------------------------------------------

// Ping

// optional uint64 timestamp = 1;
inline bool Ping::has_timestamp() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Ping::clear_timestamp() {
  timestamp_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000001u;
}
inline ::google::protobuf::uint64 Ping::timestamp() const {
  // @@protoc_insertion_point(field_get:MumbleProto.Ping.timestamp)
  return timestamp_;
}
inline void Ping::set_timestamp(::google::protobuf::uint64 value) {
  _has_bits_[0] |= 0x00000001u;
  timestamp_ = value;
  // @@protoc_insertion_point(field_set:MumbleProto.Ping.timestamp)
}

// optional uint32 good = 2;
inline bool Ping::has_good() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Ping::clear_good() {
  good_ = 0u;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::google::protobuf::uint32 Ping::good() const {
  // @@protoc_insertion_point(field_get:MumbleProto.Ping.good)
  return good_;
}
inline void Ping::set_good(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000002u;
  good_ = value;
  // @@protoc_insertion_point(field_set:MumbleProto.Ping.good)
}

// optional uint32 late = 3;
inline bool Ping::has_late() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Ping::clear_late() {
  late_ = 0u;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::google::protobuf::uint32 Ping::late() const {
  // @@protoc_insertion_point(field_get:MumbleProto.Ping.late)
  return late_;
}
inline void Ping::set_late(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000004u;
  late_ = value;
  // @@protoc_insertion_point(field_set:MumbleProto.Ping.late)
}

// optional uint32 lost = 4;
inline bool Ping::has_lost() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Ping::clear_lost() {
  lost_ = 0u;
  _has_bits_[0] &= ~0x00000008u;
}
inline ::google::protobuf::uint32 Ping::lost() const {
  // @@protoc_insertion_point(field_get:MumbleProto.Ping.lost)
  return lost_;
}
inline void Ping::set_lost(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000008u;
  lost_ = value;
  // @@protoc_insertion_point(field_set:MumbleProto.Ping.lost)
}

// optional uint32 resync = 5;
inline bool Ping::has_resync() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Ping::clear_resync() {
  resync_ = 0u;
  _has_bits_[0] &= ~0x00000010u;
}
inline ::google::protobuf::uint32 Ping::resync() const {
  // @@protoc_insertion_point(field_get:MumbleProto.Ping.resync)
  return resync_;
}
inline void Ping::set_resync(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000010u;
  resync_ = value;
  // @@protoc_insertion_point(field_set:MumbleProto.Ping.resync)
}

// optional uint32 udp_packets = 6;
inline bool Ping::has_udp_packets() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Ping::clear_udp_packets() {
  udp_packets_ = 0u;
  _has_bits_[0] &= ~0x00000020u;
}
inline ::google::protobuf::uint32 Ping::udp_packets() const {
  // @@protoc_insertion_point(field_get:MumbleProto.Ping.udp_packets)
  return udp_packets_;
}
inline void Ping::set_udp_packets(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000020u;
  udp_packets_ = value;
  // @@protoc_insertion_point(field_set:MumbleProto.Ping.udp_packets)
}

// optional uint32 tcp_packets = 7;
inline bool Ping::has_tcp_packets() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Ping::clear_tcp_packets() {
  tcp_packets_ = 0u;
  _has_bits_[0] &= ~0x00000040u;
}
inline ::google::protobuf::uint32 Ping::tcp_packets() const {
  // @@protoc_insertion_point(field_get:MumbleProto.Ping.tcp_packets)
  return tcp_packets_;
}
inline void Ping::set_tcp_packets(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000040u;
  tcp_packets_ = value;
  // @@protoc_insertion_point(field_set:MumbleProto.Ping.tcp_packets)
}

// optional float udp_ping_avg = 8;
inline bool Ping::has_udp_ping_avg() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void Ping::clear_udp_ping_avg() {
  udp_ping_avg_ = 0;
  _has_bits_[0] &= ~0x00000080u;
}
inline float Ping::udp_ping_avg() const {
  // @@protoc_insertion_point(field_get:MumbleProto.Ping.udp_ping_avg)
  return udp_ping_avg_;
}
inline void Ping::set_udp_ping_avg(float value) {
  _has_bits_[0] |= 0x00000080u;
  udp_ping_avg_ = value;
  // @@protoc_insertion_point(field_set:MumbleProto.Ping.udp_ping_avg)
}

// optional float udp_ping_var = 9;
inline bool Ping::has_udp_ping_var() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void Ping::clear_udp_ping_var() {
  udp_ping_var_ = 0;
  _has_bits_[0] &= ~0x00000100u;
}
inline float Ping::udp_ping_var() const {
  // @@protoc_insertion_point(field_get:MumbleProto.Ping.udp_ping_var)
  return udp_ping_var_;
}
inline void Ping::set_udp_ping_var(float value) {
  _has_bits_[0] |= 0x00000100u;
  udp_ping_var_ = value;
  // @@protoc_insertion_point(field_set:MumbleProto.Ping.udp_ping_var)
}

// optional float tcp_ping_avg = 10;
inline bool Ping::has_tcp_ping_avg() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void Ping::clear_tcp_ping_avg() {
  tcp_ping_avg_ = 0;
  _has_bits_[0] &= ~0x00000200u;
}
inline float Ping::tcp_ping_avg() const {
  // @@protoc_insertion_point(field_get:MumbleProto.Ping.tcp_ping_avg)
  return tcp_ping_avg_;
}
inline void Ping::set_tcp_ping_avg(float value) {
  _has_bits_[0] |= 0x00000200u;
  tcp_ping_avg_ = value;
  // @@protoc_insertion_point(field_set:MumbleProto.Ping.tcp_ping_avg)
}

// optional float tcp_ping_var = 11;
inline bool Ping::has_tcp_ping_var() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void Ping::clear_tcp_ping_var() {
  tcp_ping_var_ = 0;
  _has_bits_[0] &= ~0x00000400u;
}
inline float Ping::tcp_ping_var() const {
  // @@protoc_insertion_point(field_get:MumbleProto.Ping.tcp_ping_var)
  return tcp_ping_var_;
}
inline void Ping::set_tcp_ping_var(float value) {
  _has_bits_[0] |= 0x00000400u;
  tcp_ping_var_ = value;
  // @@protoc_insertion_point(field_set:MumbleProto.Ping.tcp_ping_var)
}

// -------------------------------------------------------------------

// Reject

// optional .MumbleProto.Reject.RejectType type = 1;
inline bool Reject::has_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Reject::clear_type() {
  type_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::MumbleProto::Reject_RejectType Reject::type() const {
  // @@protoc_insertion_point(field_get:MumbleProto.Reject.type)
  return static_cast< ::MumbleProto::Reject_RejectType >(type_);
}
inline void Reject::set_type(::MumbleProto::Reject_RejectType value) {
  assert(::MumbleProto::Reject_RejectType_IsValid(value));
  _has_bits_[0] |= 0x00000002u;
  type_ = value;
  // @@protoc_insertion_point(field_set:MumbleProto.Reject.type)
}

// optional string reason = 2;
inline bool Reject::has_reason() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Reject::clear_reason() {
  reason_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::std::string& Reject::reason() const {
  // @@protoc_insertion_point(field_get:MumbleProto.Reject.reason)
  return reason_.GetNoArena();
}
inline void Reject::set_reason(const ::std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  reason_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:MumbleProto.Reject.reason)
}
#if LANG_CXX11
inline void Reject::set_reason(::std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  reason_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:MumbleProto.Reject.reason)
}
#endif
inline void Reject::set_reason(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  reason_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:MumbleProto.Reject.reason)
}
inline void Reject::set_reason(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  reason_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:MumbleProto.Reject.reason)
}
inline ::std::string* Reject::mutable_reason() {
  _has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_mutable:MumbleProto.Reject.reason)
  return reason_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Reject::release_reason() {
  // @@protoc_insertion_point(field_release:MumbleProto.Reject.reason)
  if (!has_reason()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return reason_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Reject::set_allocated_reason(::std::string* reason) {
  if (reason != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  reason_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), reason);
  // @@protoc_insertion_point(field_set_allocated:MumbleProto.Reject.reason)
}

// -------------------------------------------------------------------

// ServerConfig

// optional uint32 max_bandwidth = 1;
inline bool ServerConfig::has_max_bandwidth() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ServerConfig::clear_max_bandwidth() {
  max_bandwidth_ = 0u;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::google::protobuf::uint32 ServerConfig::max_bandwidth() const {
  // @@protoc_insertion_point(field_get:MumbleProto.ServerConfig.max_bandwidth)
  return max_bandwidth_;
}
inline void ServerConfig::set_max_bandwidth(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000002u;
  max_bandwidth_ = value;
  // @@protoc_insertion_point(field_set:MumbleProto.ServerConfig.max_bandwidth)
}

// optional string welcome_text = 2;
inline bool ServerConfig::has_welcome_text() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ServerConfig::clear_welcome_text() {
  welcome_text_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::std::string& ServerConfig::welcome_text() const {
  // @@protoc_insertion_point(field_get:MumbleProto.ServerConfig.welcome_text)
  return welcome_text_.GetNoArena();
}
inline void ServerConfig::set_welcome_text(const ::std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  welcome_text_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:MumbleProto.ServerConfig.welcome_text)
}
#if LANG_CXX11
inline void ServerConfig::set_welcome_text(::std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  welcome_text_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:MumbleProto.ServerConfig.welcome_text)
}
#endif
inline void ServerConfig::set_welcome_text(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  welcome_text_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:MumbleProto.ServerConfig.welcome_text)
}
inline void ServerConfig::set_welcome_text(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  welcome_text_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:MumbleProto.ServerConfig.welcome_text)
}
inline ::std::string* ServerConfig::mutable_welcome_text() {
  _has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_mutable:MumbleProto.ServerConfig.welcome_text)
  return welcome_text_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ServerConfig::release_welcome_text() {
  // @@protoc_insertion_point(field_release:MumbleProto.ServerConfig.welcome_text)
  if (!has_welcome_text()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return welcome_text_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ServerConfig::set_allocated_welcome_text(::std::string* welcome_text) {
  if (welcome_text != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  welcome_text_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), welcome_text);
  // @@protoc_insertion_point(field_set_allocated:MumbleProto.ServerConfig.welcome_text)
}

// optional bool allow_html = 3;
inline bool ServerConfig::has_allow_html() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ServerConfig::clear_allow_html() {
  allow_html_ = false;
  _has_bits_[0] &= ~0x00000004u;
}
inline bool ServerConfig::allow_html() const {
  // @@protoc_insertion_point(field_get:MumbleProto.ServerConfig.allow_html)
  return allow_html_;
}
inline void ServerConfig::set_allow_html(bool value) {
  _has_bits_[0] |= 0x00000004u;
  allow_html_ = value;
  // @@protoc_insertion_point(field_set:MumbleProto.ServerConfig.allow_html)
}

// optional uint32 message_length = 4;
inline bool ServerConfig::has_message_length() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ServerConfig::clear_message_length() {
  message_length_ = 0u;
  _has_bits_[0] &= ~0x00000008u;
}
inline ::google::protobuf::uint32 ServerConfig::message_length() const {
  // @@protoc_insertion_point(field_get:MumbleProto.ServerConfig.message_length)
  return message_length_;
}
inline void ServerConfig::set_message_length(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000008u;
  message_length_ = value;
  // @@protoc_insertion_point(field_set:MumbleProto.ServerConfig.message_length)
}

// optional uint32 image_message_length = 5;
inline bool ServerConfig::has_image_message_length() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ServerConfig::clear_image_message_length() {
  image_message_length_ = 0u;
  _has_bits_[0] &= ~0x00000010u;
}
inline ::google::protobuf::uint32 ServerConfig::image_message_length() const {
  // @@protoc_insertion_point(field_get:MumbleProto.ServerConfig.image_message_length)
  return image_message_length_;
}
inline void ServerConfig::set_image_message_length(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000010u;
  image_message_length_ = value;
  // @@protoc_insertion_point(field_set:MumbleProto.ServerConfig.image_message_length)
}

// -------------------------------------------------------------------

// ServerSync

// optional uint32 session = 1;
inline bool ServerSync::has_session() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ServerSync::clear_session() {
  session_ = 0u;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::google::protobuf::uint32 ServerSync::session() const {
  // @@protoc_insertion_point(field_get:MumbleProto.ServerSync.session)
  return session_;
}
inline void ServerSync::set_session(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000002u;
  session_ = value;
  // @@protoc_insertion_point(field_set:MumbleProto.ServerSync.session)
}

// optional uint32 max_bandwidth = 2;
inline bool ServerSync::has_max_bandwidth() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ServerSync::clear_max_bandwidth() {
  max_bandwidth_ = 0u;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::google::protobuf::uint32 ServerSync::max_bandwidth() const {
  // @@protoc_insertion_point(field_get:MumbleProto.ServerSync.max_bandwidth)
  return max_bandwidth_;
}
inline void ServerSync::set_max_bandwidth(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000004u;
  max_bandwidth_ = value;
  // @@protoc_insertion_point(field_set:MumbleProto.ServerSync.max_bandwidth)
}

// optional string welcome_text = 3;
inline bool ServerSync::has_welcome_text() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ServerSync::clear_welcome_text() {
  welcome_text_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::std::string& ServerSync::welcome_text() const {
  // @@protoc_insertion_point(field_get:MumbleProto.ServerSync.welcome_text)
  return welcome_text_.GetNoArena();
}
inline void ServerSync::set_welcome_text(const ::std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  welcome_text_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:MumbleProto.ServerSync.welcome_text)
}
#if LANG_CXX11
inline void ServerSync::set_welcome_text(::std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  welcome_text_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:MumbleProto.ServerSync.welcome_text)
}
#endif
inline void ServerSync::set_welcome_text(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  welcome_text_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:MumbleProto.ServerSync.welcome_text)
}
inline void ServerSync::set_welcome_text(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  welcome_text_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:MumbleProto.ServerSync.welcome_text)
}
inline ::std::string* ServerSync::mutable_welcome_text() {
  _has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_mutable:MumbleProto.ServerSync.welcome_text)
  return welcome_text_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ServerSync::release_welcome_text() {
  // @@protoc_insertion_point(field_release:MumbleProto.ServerSync.welcome_text)
  if (!has_welcome_text()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return welcome_text_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ServerSync::set_allocated_welcome_text(::std::string* welcome_text) {
  if (welcome_text != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  welcome_text_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), welcome_text);
  // @@protoc_insertion_point(field_set_allocated:MumbleProto.ServerSync.welcome_text)
}

// optional uint64 permissions = 4;
inline bool ServerSync::has_permissions() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ServerSync::clear_permissions() {
  permissions_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000008u;
}
inline ::google::protobuf::uint64 ServerSync::permissions() const {
  // @@protoc_insertion_point(field_get:MumbleProto.ServerSync.permissions)
  return permissions_;
}
inline void ServerSync::set_permissions(::google::protobuf::uint64 value) {
  _has_bits_[0] |= 0x00000008u;
  permissions_ = value;
  // @@protoc_insertion_point(field_set:MumbleProto.ServerSync.permissions)
}

// -------------------------------------------------------------------

// ChannelRemove

// required uint32 channel_id = 1;
inline bool ChannelRemove::has_channel_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ChannelRemove::clear_channel_id() {
  channel_id_ = 0u;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::google::protobuf::uint32 ChannelRemove::channel_id() const {
  // @@protoc_insertion_point(field_get:MumbleProto.ChannelRemove.channel_id)
  return channel_id_;
}
inline void ChannelRemove::set_channel_id(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000001u;
  channel_id_ = value;
  // @@protoc_insertion_point(field_set:MumbleProto.ChannelRemove.channel_id)
}

// -------------------------------------------------------------------

// ChannelState

// optional uint32 channel_id = 1;
inline bool ChannelState::has_channel_id() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ChannelState::clear_channel_id() {
  channel_id_ = 0u;
  _has_bits_[0] &= ~0x00000008u;
}
inline ::google::protobuf::uint32 ChannelState::channel_id() const {
  // @@protoc_insertion_point(field_get:MumbleProto.ChannelState.channel_id)
  return channel_id_;
}
inline void ChannelState::set_channel_id(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000008u;
  channel_id_ = value;
  // @@protoc_insertion_point(field_set:MumbleProto.ChannelState.channel_id)
}

// optional uint32 parent = 2;
inline bool ChannelState::has_parent() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ChannelState::clear_parent() {
  parent_ = 0u;
  _has_bits_[0] &= ~0x00000010u;
}
inline ::google::protobuf::uint32 ChannelState::parent() const {
  // @@protoc_insertion_point(field_get:MumbleProto.ChannelState.parent)
  return parent_;
}
inline void ChannelState::set_parent(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000010u;
  parent_ = value;
  // @@protoc_insertion_point(field_set:MumbleProto.ChannelState.parent)
}

// optional string name = 3;
inline bool ChannelState::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ChannelState::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::std::string& ChannelState::name() const {
  // @@protoc_insertion_point(field_get:MumbleProto.ChannelState.name)
  return name_.GetNoArena();
}
inline void ChannelState::set_name(const ::std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:MumbleProto.ChannelState.name)
}
#if LANG_CXX11
inline void ChannelState::set_name(::std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:MumbleProto.ChannelState.name)
}
#endif
inline void ChannelState::set_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:MumbleProto.ChannelState.name)
}
inline void ChannelState::set_name(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:MumbleProto.ChannelState.name)
}
inline ::std::string* ChannelState::mutable_name() {
  _has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_mutable:MumbleProto.ChannelState.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ChannelState::release_name() {
  // @@protoc_insertion_point(field_release:MumbleProto.ChannelState.name)
  if (!has_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return name_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ChannelState::set_allocated_name(::std::string* name) {
  if (name != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:MumbleProto.ChannelState.name)
}

// repeated uint32 links = 4;
inline int ChannelState::links_size() const {
  return links_.size();
}
inline void ChannelState::clear_links() {
  links_.Clear();
}
inline ::google::protobuf::uint32 ChannelState::links(int index) const {
  // @@protoc_insertion_point(field_get:MumbleProto.ChannelState.links)
  return links_.Get(index);
}
inline void ChannelState::set_links(int index, ::google::protobuf::uint32 value) {
  links_.Set(index, value);
  // @@protoc_insertion_point(field_set:MumbleProto.ChannelState.links)
}
inline void ChannelState::add_links(::google::protobuf::uint32 value) {
  links_.Add(value);
  // @@protoc_insertion_point(field_add:MumbleProto.ChannelState.links)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
ChannelState::links() const {
  // @@protoc_insertion_point(field_list:MumbleProto.ChannelState.links)
  return links_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
ChannelState::mutable_links() {
  // @@protoc_insertion_point(field_mutable_list:MumbleProto.ChannelState.links)
  return &links_;
}

// optional string description = 5;
inline bool ChannelState::has_description() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ChannelState::clear_description() {
  description_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::std::string& ChannelState::description() const {
  // @@protoc_insertion_point(field_get:MumbleProto.ChannelState.description)
  return description_.GetNoArena();
}
inline void ChannelState::set_description(const ::std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  description_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:MumbleProto.ChannelState.description)
}
#if LANG_CXX11
inline void ChannelState::set_description(::std::string&& value) {
  _has_bits_[0] |= 0x00000002u;
  description_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:MumbleProto.ChannelState.description)
}
#endif
inline void ChannelState::set_description(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000002u;
  description_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:MumbleProto.ChannelState.description)
}
inline void ChannelState::set_description(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000002u;
  description_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:MumbleProto.ChannelState.description)
}
inline ::std::string* ChannelState::mutable_description() {
  _has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_mutable:MumbleProto.ChannelState.description)
  return description_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ChannelState::release_description() {
  // @@protoc_insertion_point(field_release:MumbleProto.ChannelState.description)
  if (!has_description()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return description_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ChannelState::set_allocated_description(::std::string* description) {
  if (description != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  description_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), description);
  // @@protoc_insertion_point(field_set_allocated:MumbleProto.ChannelState.description)
}

// repeated uint32 links_add = 6;
inline int ChannelState::links_add_size() const {
  return links_add_.size();
}
inline void ChannelState::clear_links_add() {
  links_add_.Clear();
}
inline ::google::protobuf::uint32 ChannelState::links_add(int index) const {
  // @@protoc_insertion_point(field_get:MumbleProto.ChannelState.links_add)
  return links_add_.Get(index);
}
inline void ChannelState::set_links_add(int index, ::google::protobuf::uint32 value) {
  links_add_.Set(index, value);
  // @@protoc_insertion_point(field_set:MumbleProto.ChannelState.links_add)
}
inline void ChannelState::add_links_add(::google::protobuf::uint32 value) {
  links_add_.Add(value);
  // @@protoc_insertion_point(field_add:MumbleProto.ChannelState.links_add)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
ChannelState::links_add() const {
  // @@protoc_insertion_point(field_list:MumbleProto.ChannelState.links_add)
  return links_add_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
ChannelState::mutable_links_add() {
  // @@protoc_insertion_point(field_mutable_list:MumbleProto.ChannelState.links_add)
  return &links_add_;
}

// repeated uint32 links_remove = 7;
inline int ChannelState::links_remove_size() const {
  return links_remove_.size();
}
inline void ChannelState::clear_links_remove() {
  links_remove_.Clear();
}
inline ::google::protobuf::uint32 ChannelState::links_remove(int index) const {
  // @@protoc_insertion_point(field_get:MumbleProto.ChannelState.links_remove)
  return links_remove_.Get(index);
}
inline void ChannelState::set_links_remove(int index, ::google::protobuf::uint32 value) {
  links_remove_.Set(index, value);
  // @@protoc_insertion_point(field_set:MumbleProto.ChannelState.links_remove)
}
inline void ChannelState::add_links_remove(::google::protobuf::uint32 value) {
  links_remove_.Add(value);
  // @@protoc_insertion_point(field_add:MumbleProto.ChannelState.links_remove)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
ChannelState::links_remove() const {
  // @@protoc_insertion_point(field_list:MumbleProto.ChannelState.links_remove)
  return links_remove_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
ChannelState::mutable_links_remove() {
  // @@protoc_insertion_point(field_mutable_list:MumbleProto.ChannelState.links_remove)
  return &links_remove_;
}

// optional bool temporary = 8 [default = false];
inline bool ChannelState::has_temporary() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ChannelState::clear_temporary() {
  temporary_ = false;
  _has_bits_[0] &= ~0x00000020u;
}
inline bool ChannelState::temporary() const {
  // @@protoc_insertion_point(field_get:MumbleProto.ChannelState.temporary)
  return temporary_;
}
inline void ChannelState::set_temporary(bool value) {
  _has_bits_[0] |= 0x00000020u;
  temporary_ = value;
  // @@protoc_insertion_point(field_set:MumbleProto.ChannelState.temporary)
}

// optional int32 position = 9 [default = 0];
inline bool ChannelState::has_position() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void ChannelState::clear_position() {
  position_ = 0;
  _has_bits_[0] &= ~0x00000040u;
}
inline ::google::protobuf::int32 ChannelState::position() const {
  // @@protoc_insertion_point(field_get:MumbleProto.ChannelState.position)
  return position_;
}
inline void ChannelState::set_position(::google::protobuf::int32 value) {
  _has_bits_[0] |= 0x00000040u;
  position_ = value;
  // @@protoc_insertion_point(field_set:MumbleProto.ChannelState.position)
}

// optional bytes description_hash = 10;
inline bool ChannelState::has_description_hash() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ChannelState::clear_description_hash() {
  description_hash_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000004u;
}
inline const ::std::string& ChannelState::description_hash() const {
  // @@protoc_insertion_point(field_get:MumbleProto.ChannelState.description_hash)
  return description_hash_.GetNoArena();
}
inline void ChannelState::set_description_hash(const ::std::string& value) {
  _has_bits_[0] |= 0x00000004u;
  description_hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:MumbleProto.ChannelState.description_hash)
}
#if LANG_CXX11
inline void ChannelState::set_description_hash(::std::string&& value) {
  _has_bits_[0] |= 0x00000004u;
  description_hash_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:MumbleProto.ChannelState.description_hash)
}
#endif
inline void ChannelState::set_description_hash(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000004u;
  description_hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:MumbleProto.ChannelState.description_hash)
}
inline void ChannelState::set_description_hash(const void* value, size_t size) {
  _has_bits_[0] |= 0x00000004u;
  description_hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:MumbleProto.ChannelState.description_hash)
}
inline ::std::string* ChannelState::mutable_description_hash() {
  _has_bits_[0] |= 0x00000004u;
  // @@protoc_insertion_point(field_mutable:MumbleProto.ChannelState.description_hash)
  return description_hash_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ChannelState::release_description_hash() {
  // @@protoc_insertion_point(field_release:MumbleProto.ChannelState.description_hash)
  if (!has_description_hash()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000004u;
  return description_hash_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ChannelState::set_allocated_description_hash(::std::string* description_hash) {
  if (description_hash != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  description_hash_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), description_hash);
  // @@protoc_insertion_point(field_set_allocated:MumbleProto.ChannelState.description_hash)
}

// -------------------------------------------------------------------

// UserRemove

// required uint32 session = 1;
inline bool UserRemove::has_session() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UserRemove::clear_session() {
  session_ = 0u;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::google::protobuf::uint32 UserRemove::session() const {
  // @@protoc_insertion_point(field_get:MumbleProto.UserRemove.session)
  return session_;
}
inline void UserRemove::set_session(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000002u;
  session_ = value;
  // @@protoc_insertion_point(field_set:MumbleProto.UserRemove.session)
}

// optional uint32 actor = 2;
inline bool UserRemove::has_actor() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void UserRemove::clear_actor() {
  actor_ = 0u;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::google::protobuf::uint32 UserRemove::actor() const {
  // @@protoc_insertion_point(field_get:MumbleProto.UserRemove.actor)
  return actor_;
}
inline void UserRemove::set_actor(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000004u;
  actor_ = value;
  // @@protoc_insertion_point(field_set:MumbleProto.UserRemove.actor)
}

// optional string reason = 3;
inline bool UserRemove::has_reason() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UserRemove::clear_reason() {
  reason_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::std::string& UserRemove::reason() const {
  // @@protoc_insertion_point(field_get:MumbleProto.UserRemove.reason)
  return reason_.GetNoArena();
}
inline void UserRemove::set_reason(const ::std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  reason_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:MumbleProto.UserRemove.reason)
}
#if LANG_CXX11
inline void UserRemove::set_reason(::std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  reason_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:MumbleProto.UserRemove.reason)
}
#endif
inline void UserRemove::set_reason(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  reason_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:MumbleProto.UserRemove.reason)
}
inline void UserRemove::set_reason(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  reason_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:MumbleProto.UserRemove.reason)
}
inline ::std::string* UserRemove::mutable_reason() {
  _has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_mutable:MumbleProto.UserRemove.reason)
  return reason_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* UserRemove::release_reason() {
  // @@protoc_insertion_point(field_release:MumbleProto.UserRemove.reason)
  if (!has_reason()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return reason_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void UserRemove::set_allocated_reason(::std::string* reason) {
  if (reason != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  reason_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), reason);
  // @@protoc_insertion_point(field_set_allocated:MumbleProto.UserRemove.reason)
}

// optional bool ban = 4;
inline bool UserRemove::has_ban() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void UserRemove::clear_ban() {
  ban_ = false;
  _has_bits_[0] &= ~0x00000008u;
}
inline bool UserRemove::ban() const {
  // @@protoc_insertion_point(field_get:MumbleProto.UserRemove.ban)
  return ban_;
}
inline void UserRemove::set_ban(bool value) {
  _has_bits_[0] |= 0x00000008u;
  ban_ = value;
  // @@protoc_insertion_point(field_set:MumbleProto.UserRemove.ban)
}

// -------------------------------------------------------------------

// UserState

// optional uint32 session = 1;
inline bool UserState::has_session() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void UserState::clear_session() {
  session_ = 0u;
  _has_bits_[0] &= ~0x00000100u;
}
inline ::google::protobuf::uint32 UserState::session() const {
  // @@protoc_insertion_point(field_get:MumbleProto.UserState.session)
  return session_;
}
inline void UserState::set_session(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000100u;
  session_ = value;
  // @@protoc_insertion_point(field_set:MumbleProto.UserState.session)
}

// optional uint32 actor = 2;
inline bool UserState::has_actor() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void UserState::clear_actor() {
  actor_ = 0u;
  _has_bits_[0] &= ~0x00000200u;
}
inline ::google::protobuf::uint32 UserState::actor() const {
  // @@protoc_insertion_point(field_get:MumbleProto.UserState.actor)
  return actor_;
}
inline void UserState::set_actor(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000200u;
  actor_ = value;
  // @@protoc_insertion_point(field_set:MumbleProto.UserState.actor)
}

// optional string name = 3;
inline bool UserState::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UserState::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::std::string& UserState::name() const {
  // @@protoc_insertion_point(field_get:MumbleProto.UserState.name)
  return name_.GetNoArena();
}
inline void UserState::set_name(const ::std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:MumbleProto.UserState.name)
}
#if LANG_CXX11
inline void UserState::set_name(::std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:MumbleProto.UserState.name)
}
#endif
inline void UserState::set_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:MumbleProto.UserState.name)
}
inline void UserState::set_name(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:MumbleProto.UserState.name)
}
inline ::std::string* UserState::mutable_name() {
  _has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_mutable:MumbleProto.UserState.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* UserState::release_name() {
  // @@protoc_insertion_point(field_release:MumbleProto.UserState.name)
  if (!has_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return name_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void UserState::set_allocated_name(::std::string* name) {
  if (name != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:MumbleProto.UserState.name)
}

// optional uint32 user_id = 4;
inline bool UserState::has_user_id() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void UserState::clear_user_id() {
  user_id_ = 0u;
  _has_bits_[0] &= ~0x00000400u;
}
inline ::google::protobuf::uint32 UserState::user_id() const {
  // @@protoc_insertion_point(field_get:MumbleProto.UserState.user_id)
  return user_id_;
}
inline void UserState::set_user_id(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000400u;
  user_id_ = value;
  // @@protoc_insertion_point(field_set:MumbleProto.UserState.user_id)
}

// optional uint32 channel_id = 5;
inline bool UserState::has_channel_id() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void UserState::clear_channel_id() {
  channel_id_ = 0u;
  _has_bits_[0] &= ~0x00000800u;
}
inline ::google::protobuf::uint32 UserState::channel_id() const {
  // @@protoc_insertion_point(field_get:MumbleProto.UserState.channel_id)
  return channel_id_;
}
inline void UserState::set_channel_id(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000800u;
  channel_id_ = value;
  // @@protoc_insertion_point(field_set:MumbleProto.UserState.channel_id)
}

// optional bool mute = 6;
inline bool UserState::has_mute() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void UserState::clear_mute() {
  mute_ = false;
  _has_bits_[0] &= ~0x00001000u;
}
inline bool UserState::mute() const {
  // @@protoc_insertion_point(field_get:MumbleProto.UserState.mute)
  return mute_;
}
inline void UserState::set_mute(bool value) {
  _has_bits_[0] |= 0x00001000u;
  mute_ = value;
  // @@protoc_insertion_point(field_set:MumbleProto.UserState.mute)
}

// optional bool deaf = 7;
inline bool UserState::has_deaf() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void UserState::clear_deaf() {
  deaf_ = false;
  _has_bits_[0] &= ~0x00002000u;
}
inline bool UserState::deaf() const {
  // @@protoc_insertion_point(field_get:MumbleProto.UserState.deaf)
  return deaf_;
}
inline void UserState::set_deaf(bool value) {
  _has_bits_[0] |= 0x00002000u;
  deaf_ = value;
  // @@protoc_insertion_point(field_set:MumbleProto.UserState.deaf)
}

// optional bool suppress = 8;
inline bool UserState::has_suppress() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void UserState::clear_suppress() {
  suppress_ = false;
  _has_bits_[0] &= ~0x00004000u;
}
inline bool UserState::suppress() const {
  // @@protoc_insertion_point(field_get:MumbleProto.UserState.suppress)
  return suppress_;
}
inline void UserState::set_suppress(bool value) {
  _has_bits_[0] |= 0x00004000u;
  suppress_ = value;
  // @@protoc_insertion_point(field_set:MumbleProto.UserState.suppress)
}

// optional bool self_mute = 9;
inline bool UserState::has_self_mute() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void UserState::clear_self_mute() {
  self_mute_ = false;
  _has_bits_[0] &= ~0x00008000u;
}
inline bool UserState::self_mute() const {
  // @@protoc_insertion_point(field_get:MumbleProto.UserState.self_mute)
  return self_mute_;
}
inline void UserState::set_self_mute(bool value) {
  _has_bits_[0] |= 0x00008000u;
  self_mute_ = value;
  // @@protoc_insertion_point(field_set:MumbleProto.UserState.self_mute)
}

// optional bool self_deaf = 10;
inline bool UserState::has_self_deaf() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void UserState::clear_self_deaf() {
  self_deaf_ = false;
  _has_bits_[0] &= ~0x00010000u;
}
inline bool UserState::self_deaf() const {
  // @@protoc_insertion_point(field_get:MumbleProto.UserState.self_deaf)
  return self_deaf_;
}
inline void UserState::set_self_deaf(bool value) {
  _has_bits_[0] |= 0x00010000u;
  self_deaf_ = value;
  // @@protoc_insertion_point(field_set:MumbleProto.UserState.self_deaf)
}

// optional bytes texture = 11;
inline bool UserState::has_texture() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UserState::clear_texture() {
  texture_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::std::string& UserState::texture() const {
  // @@protoc_insertion_point(field_get:MumbleProto.UserState.texture)
  return texture_.GetNoArena();
}
inline void UserState::set_texture(const ::std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  texture_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:MumbleProto.UserState.texture)
}
#if LANG_CXX11
inline void UserState::set_texture(::std::string&& value) {
  _has_bits_[0] |= 0x00000002u;
  texture_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:MumbleProto.UserState.texture)
}
#endif
inline void UserState::set_texture(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000002u;
  texture_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:MumbleProto.UserState.texture)
}
inline void UserState::set_texture(const void* value, size_t size) {
  _has_bits_[0] |= 0x00000002u;
  texture_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:MumbleProto.UserState.texture)
}
inline ::std::string* UserState::mutable_texture() {
  _has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_mutable:MumbleProto.UserState.texture)
  return texture_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* UserState::release_texture() {
  // @@protoc_insertion_point(field_release:MumbleProto.UserState.texture)
  if (!has_texture()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return texture_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void UserState::set_allocated_texture(::std::string* texture) {
  if (texture != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  texture_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), texture);
  // @@protoc_insertion_point(field_set_allocated:MumbleProto.UserState.texture)
}

// optional bytes plugin_context = 12;
inline bool UserState::has_plugin_context() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void UserState::clear_plugin_context() {
  plugin_context_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000004u;
}
inline const ::std::string& UserState::plugin_context() const {
  // @@protoc_insertion_point(field_get:MumbleProto.UserState.plugin_context)
  return plugin_context_.GetNoArena();
}
inline void UserState::set_plugin_context(const ::std::string& value) {
  _has_bits_[0] |= 0x00000004u;
  plugin_context_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:MumbleProto.UserState.plugin_context)
}
#if LANG_CXX11
inline void UserState::set_plugin_context(::std::string&& value) {
  _has_bits_[0] |= 0x00000004u;
  plugin_context_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:MumbleProto.UserState.plugin_context)
}
#endif
inline void UserState::set_plugin_context(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000004u;
  plugin_context_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:MumbleProto.UserState.plugin_context)
}
inline void UserState::set_plugin_context(const void* value, size_t size) {
  _has_bits_[0] |= 0x00000004u;
  plugin_context_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:MumbleProto.UserState.plugin_context)
}
inline ::std::string* UserState::mutable_plugin_context() {
  _has_bits_[0] |= 0x00000004u;
  // @@protoc_insertion_point(field_mutable:MumbleProto.UserState.plugin_context)
  return plugin_context_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* UserState::release_plugin_context() {
  // @@protoc_insertion_point(field_release:MumbleProto.UserState.plugin_context)
  if (!has_plugin_context()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000004u;
  return plugin_context_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void UserState::set_allocated_plugin_context(::std::string* plugin_context) {
  if (plugin_context != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  plugin_context_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), plugin_context);
  // @@protoc_insertion_point(field_set_allocated:MumbleProto.UserState.plugin_context)
}

// optional string plugin_identity = 13;
inline bool UserState::has_plugin_identity() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void UserState::clear_plugin_identity() {
  plugin_identity_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000008u;
}
inline const ::std::string& UserState::plugin_identity() const {
  // @@protoc_insertion_point(field_get:MumbleProto.UserState.plugin_identity)
  return plugin_identity_.GetNoArena();
}
inline void UserState::set_plugin_identity(const ::std::string& value) {
  _has_bits_[0] |= 0x00000008u;
  plugin_identity_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:MumbleProto.UserState.plugin_identity)
}
#if LANG_CXX11
inline void UserState::set_plugin_identity(::std::string&& value) {
  _has_bits_[0] |= 0x00000008u;
  plugin_identity_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:MumbleProto.UserState.plugin_identity)
}
#endif
inline void UserState::set_plugin_identity(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000008u;
  plugin_identity_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:MumbleProto.UserState.plugin_identity)
}
inline void UserState::set_plugin_identity(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000008u;
  plugin_identity_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:MumbleProto.UserState.plugin_identity)
}
inline ::std::string* UserState::mutable_plugin_identity() {
  _has_bits_[0] |= 0x00000008u;
  // @@protoc_insertion_point(field_mutable:MumbleProto.UserState.plugin_identity)
  return plugin_identity_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* UserState::release_plugin_identity() {
  // @@protoc_insertion_point(field_release:MumbleProto.UserState.plugin_identity)
  if (!has_plugin_identity()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000008u;
  return plugin_identity_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void UserState::set_allocated_plugin_identity(::std::string* plugin_identity) {
  if (plugin_identity != nullptr) {
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  plugin_identity_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), plugin_identity);
  // @@protoc_insertion_point(field_set_allocated:MumbleProto.UserState.plugin_identity)
}

// optional string comment = 14;
inline bool UserState::has_comment() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void UserState::clear_comment() {
  comment_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000010u;
}
inline const ::std::string& UserState::comment() const {
  // @@protoc_insertion_point(field_get:MumbleProto.UserState.comment)
  return comment_.GetNoArena();
}
inline void UserState::set_comment(const ::std::string& value) {
  _has_bits_[0] |= 0x00000010u;
  comment_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:MumbleProto.UserState.comment)
}
#if LANG_CXX11
inline void UserState::set_comment(::std::string&& value) {
  _has_bits_[0] |= 0x00000010u;
  comment_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:MumbleProto.UserState.comment)
}
#endif
inline void UserState::set_comment(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000010u;
  comment_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:MumbleProto.UserState.comment)
}
inline void UserState::set_comment(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000010u;
  comment_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:MumbleProto.UserState.comment)
}
inline ::std::string* UserState::mutable_comment() {
  _has_bits_[0] |= 0x00000010u;
  // @@protoc_insertion_point(field_mutable:MumbleProto.UserState.comment)
  return comment_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* UserState::release_comment() {
  // @@protoc_insertion_point(field_release:MumbleProto.UserState.comment)
  if (!has_comment()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000010u;
  return comment_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void UserState::set_allocated_comment(::std::string* comment) {
  if (comment != nullptr) {
    _has_bits_[0] |= 0x00000010u;
  } else {
    _has_bits_[0] &= ~0x00000010u;
  }
  comment_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), comment);
  // @@protoc_insertion_point(field_set_allocated:MumbleProto.UserState.comment)
}

// optional string hash = 15;
inline bool UserState::has_hash() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void UserState::clear_hash() {
  hash_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000020u;
}
inline const ::std::string& UserState::hash() const {
  // @@protoc_insertion_point(field_get:MumbleProto.UserState.hash)
  return hash_.GetNoArena();
}
inline void UserState::set_hash(const ::std::string& value) {
  _has_bits_[0] |= 0x00000020u;
  hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:MumbleProto.UserState.hash)
}
#if LANG_CXX11
inline void UserState::set_hash(::std::string&& value) {
  _has_bits_[0] |= 0x00000020u;
  hash_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:MumbleProto.UserState.hash)
}
#endif
inline void UserState::set_hash(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000020u;
  hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:MumbleProto.UserState.hash)
}
inline void UserState::set_hash(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000020u;
  hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:MumbleProto.UserState.hash)
}
inline ::std::string* UserState::mutable_hash() {
  _has_bits_[0] |= 0x00000020u;
  // @@protoc_insertion_point(field_mutable:MumbleProto.UserState.hash)
  return hash_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* UserState::release_hash() {
  // @@protoc_insertion_point(field_release:MumbleProto.UserState.hash)
  if (!has_hash()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000020u;
  return hash_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void UserState::set_allocated_hash(::std::string* hash) {
  if (hash != nullptr) {
    _has_bits_[0] |= 0x00000020u;
  } else {
    _has_bits_[0] &= ~0x00000020u;
  }
  hash_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), hash);
  // @@protoc_insertion_point(field_set_allocated:MumbleProto.UserState.hash)
}

// optional bytes comment_hash = 16;
inline bool UserState::has_comment_hash() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void UserState::clear_comment_hash() {
  comment_hash_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000040u;
}
inline const ::std::string& UserState::comment_hash() const {
  // @@protoc_insertion_point(field_get:MumbleProto.UserState.comment_hash)
  return comment_hash_.GetNoArena();
}
inline void UserState::set_comment_hash(const ::std::string& value) {
  _has_bits_[0] |= 0x00000040u;
  comment_hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:MumbleProto.UserState.comment_hash)
}
#if LANG_CXX11
inline void UserState::set_comment_hash(::std::string&& value) {
  _has_bits_[0] |= 0x00000040u;
  comment_hash_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:MumbleProto.UserState.comment_hash)
}
#endif
inline void UserState::set_comment_hash(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000040u;
  comment_hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:MumbleProto.UserState.comment_hash)
}
inline void UserState::set_comment_hash(const void* value, size_t size) {
  _has_bits_[0] |= 0x00000040u;
  comment_hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:MumbleProto.UserState.comment_hash)
}
inline ::std::string* UserState::mutable_comment_hash() {
  _has_bits_[0] |= 0x00000040u;
  // @@protoc_insertion_point(field_mutable:MumbleProto.UserState.comment_hash)
  return comment_hash_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* UserState::release_comment_hash() {
  // @@protoc_insertion_point(field_release:MumbleProto.UserState.comment_hash)
  if (!has_comment_hash()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000040u;
  return comment_hash_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void UserState::set_allocated_comment_hash(::std::string* comment_hash) {
  if (comment_hash != nullptr) {
    _has_bits_[0] |= 0x00000040u;
  } else {
    _has_bits_[0] &= ~0x00000040u;
  }
  comment_hash_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), comment_hash);
  // @@protoc_insertion_point(field_set_allocated:MumbleProto.UserState.comment_hash)
}

// optional bytes texture_hash = 17;
inline bool UserState::has_texture_hash() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void UserState::clear_texture_hash() {
  texture_hash_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000080u;
}
inline const ::std::string& UserState::texture_hash() const {
  // @@protoc_insertion_point(field_get:MumbleProto.UserState.texture_hash)
  return texture_hash_.GetNoArena();
}
inline void UserState::set_texture_hash(const ::std::string& value) {
  _has_bits_[0] |= 0x00000080u;
  texture_hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:MumbleProto.UserState.texture_hash)
}
#if LANG_CXX11
inline void UserState::set_texture_hash(::std::string&& value) {
  _has_bits_[0] |= 0x00000080u;
  texture_hash_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:MumbleProto.UserState.texture_hash)
}
#endif
inline void UserState::set_texture_hash(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000080u;
  texture_hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:MumbleProto.UserState.texture_hash)
}
inline void UserState::set_texture_hash(const void* value, size_t size) {
  _has_bits_[0] |= 0x00000080u;
  texture_hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:MumbleProto.UserState.texture_hash)
}
inline ::std::string* UserState::mutable_texture_hash() {
  _has_bits_[0] |= 0x00000080u;
  // @@protoc_insertion_point(field_mutable:MumbleProto.UserState.texture_hash)
  return texture_hash_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* UserState::release_texture_hash() {
  // @@protoc_insertion_point(field_release:MumbleProto.UserState.texture_hash)
  if (!has_texture_hash()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000080u;
  return texture_hash_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void UserState::set_allocated_texture_hash(::std::string* texture_hash) {
  if (texture_hash != nullptr) {
    _has_bits_[0] |= 0x00000080u;
  } else {
    _has_bits_[0] &= ~0x00000080u;
  }
  texture_hash_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), texture_hash);
  // @@protoc_insertion_point(field_set_allocated:MumbleProto.UserState.texture_hash)
}

// optional bool priority_speaker = 18;
inline bool UserState::has_priority_speaker() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void UserState::clear_priority_speaker() {
  priority_speaker_ = false;
  _has_bits_[0] &= ~0x00020000u;
}
inline bool UserState::priority_speaker() const {
  // @@protoc_insertion_point(field_get:MumbleProto.UserState.priority_speaker)
  return priority_speaker_;
}
inline void UserState::set_priority_speaker(bool value) {
  _has_bits_[0] |= 0x00020000u;
  priority_speaker_ = value;
  // @@protoc_insertion_point(field_set:MumbleProto.UserState.priority_speaker)
}

// optional bool recording = 19;
inline bool UserState::has_recording() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void UserState::clear_recording() {
  recording_ = false;
  _has_bits_[0] &= ~0x00040000u;
}
inline bool UserState::recording() const {
  // @@protoc_insertion_point(field_get:MumbleProto.UserState.recording)
  return recording_;
}
inline void UserState::set_recording(bool value) {
  _has_bits_[0] |= 0x00040000u;
  recording_ = value;
  // @@protoc_insertion_point(field_set:MumbleProto.UserState.recording)
}

// -------------------------------------------------------------------

// BanList_BanEntry

// required bytes address = 1;
inline bool BanList_BanEntry::has_address() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BanList_BanEntry::clear_address() {
  address_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::std::string& BanList_BanEntry::address() const {
  // @@protoc_insertion_point(field_get:MumbleProto.BanList.BanEntry.address)
  return address_.GetNoArena();
}
inline void BanList_BanEntry::set_address(const ::std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:MumbleProto.BanList.BanEntry.address)
}
#if LANG_CXX11
inline void BanList_BanEntry::set_address(::std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  address_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:MumbleProto.BanList.BanEntry.address)
}
#endif
inline void BanList_BanEntry::set_address(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:MumbleProto.BanList.BanEntry.address)
}
inline void BanList_BanEntry::set_address(const void* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:MumbleProto.BanList.BanEntry.address)
}
inline ::std::string* BanList_BanEntry::mutable_address() {
  _has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_mutable:MumbleProto.BanList.BanEntry.address)
  return address_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* BanList_BanEntry::release_address() {
  // @@protoc_insertion_point(field_release:MumbleProto.BanList.BanEntry.address)
  if (!has_address()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return address_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void BanList_BanEntry::set_allocated_address(::std::string* address) {
  if (address != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  address_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), address);
  // @@protoc_insertion_point(field_set_allocated:MumbleProto.BanList.BanEntry.address)
}

// required uint32 mask = 2;
inline bool BanList_BanEntry::has_mask() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void BanList_BanEntry::clear_mask() {
  mask_ = 0u;
  _has_bits_[0] &= ~0x00000020u;
}
inline ::google::protobuf::uint32 BanList_BanEntry::mask() const {
  // @@protoc_insertion_point(field_get:MumbleProto.BanList.BanEntry.mask)
  return mask_;
}
inline void BanList_BanEntry::set_mask(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000020u;
  mask_ = value;
  // @@protoc_insertion_point(field_set:MumbleProto.BanList.BanEntry.mask)
}

// optional string name = 3;
inline bool BanList_BanEntry::has_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void BanList_BanEntry::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::std::string& BanList_BanEntry::name() const {
  // @@protoc_insertion_point(field_get:MumbleProto.BanList.BanEntry.name)
  return name_.GetNoArena();
}
inline void BanList_BanEntry::set_name(const ::std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:MumbleProto.BanList.BanEntry.name)
}
#if LANG_CXX11
inline void BanList_BanEntry::set_name(::std::string&& value) {
  _has_bits_[0] |= 0x00000002u;
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:MumbleProto.BanList.BanEntry.name)
}
#endif
inline void BanList_BanEntry::set_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000002u;
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:MumbleProto.BanList.BanEntry.name)
}
inline void BanList_BanEntry::set_name(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000002u;
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:MumbleProto.BanList.BanEntry.name)
}
inline ::std::string* BanList_BanEntry::mutable_name() {
  _has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_mutable:MumbleProto.BanList.BanEntry.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* BanList_BanEntry::release_name() {
  // @@protoc_insertion_point(field_release:MumbleProto.BanList.BanEntry.name)
  if (!has_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return name_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void BanList_BanEntry::set_allocated_name(::std::string* name) {
  if (name != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:MumbleProto.BanList.BanEntry.name)
}

// optional string hash = 4;
inline bool BanList_BanEntry::has_hash() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void BanList_BanEntry::clear_hash() {
  hash_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000004u;
}
inline const ::std::string& BanList_BanEntry::hash() const {
  // @@protoc_insertion_point(field_get:MumbleProto.BanList.BanEntry.hash)
  return hash_.GetNoArena();
}
inline void BanList_BanEntry::set_hash(const ::std::string& value) {
  _has_bits_[0] |= 0x00000004u;
  hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:MumbleProto.BanList.BanEntry.hash)
}
#if LANG_CXX11
inline void BanList_BanEntry::set_hash(::std::string&& value) {
  _has_bits_[0] |= 0x00000004u;
  hash_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:MumbleProto.BanList.BanEntry.hash)
}
#endif
inline void BanList_BanEntry::set_hash(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000004u;
  hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:MumbleProto.BanList.BanEntry.hash)
}
inline void BanList_BanEntry::set_hash(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000004u;
  hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:MumbleProto.BanList.BanEntry.hash)
}
inline ::std::string* BanList_BanEntry::mutable_hash() {
  _has_bits_[0] |= 0x00000004u;
  // @@protoc_insertion_point(field_mutable:MumbleProto.BanList.BanEntry.hash)
  return hash_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* BanList_BanEntry::release_hash() {
  // @@protoc_insertion_point(field_release:MumbleProto.BanList.BanEntry.hash)
  if (!has_hash()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000004u;
  return hash_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void BanList_BanEntry::set_allocated_hash(::std::string* hash) {
  if (hash != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  hash_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), hash);
  // @@protoc_insertion_point(field_set_allocated:MumbleProto.BanList.BanEntry.hash)
}

// optional string reason = 5;
inline bool BanList_BanEntry::has_reason() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void BanList_BanEntry::clear_reason() {
  reason_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000008u;
}
inline const ::std::string& BanList_BanEntry::reason() const {
  // @@protoc_insertion_point(field_get:MumbleProto.BanList.BanEntry.reason)
  return reason_.GetNoArena();
}
inline void BanList_BanEntry::set_reason(const ::std::string& value) {
  _has_bits_[0] |= 0x00000008u;
  reason_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:MumbleProto.BanList.BanEntry.reason)
}
#if LANG_CXX11
inline void BanList_BanEntry::set_reason(::std::string&& value) {
  _has_bits_[0] |= 0x00000008u;
  reason_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:MumbleProto.BanList.BanEntry.reason)
}
#endif
inline void BanList_BanEntry::set_reason(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000008u;
  reason_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:MumbleProto.BanList.BanEntry.reason)
}
inline void BanList_BanEntry::set_reason(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000008u;
  reason_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:MumbleProto.BanList.BanEntry.reason)
}
inline ::std::string* BanList_BanEntry::mutable_reason() {
  _has_bits_[0] |= 0x00000008u;
  // @@protoc_insertion_point(field_mutable:MumbleProto.BanList.BanEntry.reason)
  return reason_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* BanList_BanEntry::release_reason() {
  // @@protoc_insertion_point(field_release:MumbleProto.BanList.BanEntry.reason)
  if (!has_reason()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000008u;
  return reason_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void BanList_BanEntry::set_allocated_reason(::std::string* reason) {
  if (reason != nullptr) {
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  reason_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), reason);
  // @@protoc_insertion_point(field_set_allocated:MumbleProto.BanList.BanEntry.reason)
}

// optional string start = 6;
inline bool BanList_BanEntry::has_start() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void BanList_BanEntry::clear_start() {
  start_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000010u;
}
inline const ::std::string& BanList_BanEntry::start() const {
  // @@protoc_insertion_point(field_get:MumbleProto.BanList.BanEntry.start)
  return start_.GetNoArena();
}
inline void BanList_BanEntry::set_start(const ::std::string& value) {
  _has_bits_[0] |= 0x00000010u;
  start_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:MumbleProto.BanList.BanEntry.start)
}
#if LANG_CXX11
inline void BanList_BanEntry::set_start(::std::string&& value) {
  _has_bits_[0] |= 0x00000010u;
  start_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:MumbleProto.BanList.BanEntry.start)
}
#endif
inline void BanList_BanEntry::set_start(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000010u;
  start_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:MumbleProto.BanList.BanEntry.start)
}
inline void BanList_BanEntry::set_start(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000010u;
  start_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:MumbleProto.BanList.BanEntry.start)
}
inline ::std::string* BanList_BanEntry::mutable_start() {
  _has_bits_[0] |= 0x00000010u;
  // @@protoc_insertion_point(field_mutable:MumbleProto.BanList.BanEntry.start)
  return start_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* BanList_BanEntry::release_start() {
  // @@protoc_insertion_point(field_release:MumbleProto.BanList.BanEntry.start)
  if (!has_start()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000010u;
  return start_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void BanList_BanEntry::set_allocated_start(::std::string* start) {
  if (start != nullptr) {
    _has_bits_[0] |= 0x00000010u;
  } else {
    _has_bits_[0] &= ~0x00000010u;
  }
  start_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), start);
  // @@protoc_insertion_point(field_set_allocated:MumbleProto.BanList.BanEntry.start)
}

// optional uint32 duration = 7;
inline bool BanList_BanEntry::has_duration() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void BanList_BanEntry::clear_duration() {
  duration_ = 0u;
  _has_bits_[0] &= ~0x00000040u;
}
inline ::google::protobuf::uint32 BanList_BanEntry::duration() const {
  // @@protoc_insertion_point(field_get:MumbleProto.BanList.BanEntry.duration)
  return duration_;
}
inline void BanList_BanEntry::set_duration(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000040u;
  duration_ = value;
  // @@protoc_insertion_point(field_set:MumbleProto.BanList.BanEntry.duration)
}

// -------------------------------------------------------------------

// BanList

// repeated .MumbleProto.BanList.BanEntry bans = 1;
inline int BanList::bans_size() const {
  return bans_.size();
}
inline void BanList::clear_bans() {
  bans_.Clear();
}
inline ::MumbleProto::BanList_BanEntry* BanList::mutable_bans(int index) {
  // @@protoc_insertion_point(field_mutable:MumbleProto.BanList.bans)
  return bans_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::MumbleProto::BanList_BanEntry >*
BanList::mutable_bans() {
  // @@protoc_insertion_point(field_mutable_list:MumbleProto.BanList.bans)
  return &bans_;
}
inline const ::MumbleProto::BanList_BanEntry& BanList::bans(int index) const {
  // @@protoc_insertion_point(field_get:MumbleProto.BanList.bans)
  return bans_.Get(index);
}
inline ::MumbleProto::BanList_BanEntry* BanList::add_bans() {
  // @@protoc_insertion_point(field_add:MumbleProto.BanList.bans)
  return bans_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::MumbleProto::BanList_BanEntry >&
BanList::bans() const {
  // @@protoc_insertion_point(field_list:MumbleProto.BanList.bans)
  return bans_;
}

// optional bool query = 2 [default = false];
inline bool BanList::has_query() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BanList::clear_query() {
  query_ = false;
  _has_bits_[0] &= ~0x00000001u;
}
inline bool BanList::query() const {
  // @@protoc_insertion_point(field_get:MumbleProto.BanList.query)
  return query_;
}
inline void BanList::set_query(bool value) {
  _has_bits_[0] |= 0x00000001u;
  query_ = value;
  // @@protoc_insertion_point(field_set:MumbleProto.BanList.query)
}

// -------------------------------------------------------------------

// TextMessage

// optional uint32 actor = 1;
inline bool TextMessage::has_actor() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TextMessage::clear_actor() {
  actor_ = 0u;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::google::protobuf::uint32 TextMessage::actor() const {
  // @@protoc_insertion_point(field_get:MumbleProto.TextMessage.actor)
  return actor_;
}
inline void TextMessage::set_actor(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000002u;
  actor_ = value;
  // @@protoc_insertion_point(field_set:MumbleProto.TextMessage.actor)
}

// repeated uint32 session = 2;
inline int TextMessage::session_size() const {
  return session_.size();
}
inline void TextMessage::clear_session() {
  session_.Clear();
}
inline ::google::protobuf::uint32 TextMessage::session(int index) const {
  // @@protoc_insertion_point(field_get:MumbleProto.TextMessage.session)
  return session_.Get(index);
}
inline void TextMessage::set_session(int index, ::google::protobuf::uint32 value) {
  session_.Set(index, value);
  // @@protoc_insertion_point(field_set:MumbleProto.TextMessage.session)
}
inline void TextMessage::add_session(::google::protobuf::uint32 value) {
  session_.Add(value);
  // @@protoc_insertion_point(field_add:MumbleProto.TextMessage.session)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
TextMessage::session() const {
  // @@protoc_insertion_point(field_list:MumbleProto.TextMessage.session)
  return session_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
TextMessage::mutable_session() {
  // @@protoc_insertion_point(field_mutable_list:MumbleProto.TextMessage.session)
  return &session_;
}

// repeated uint32 channel_id = 3;
inline int TextMessage::channel_id_size() const {
  return channel_id_.size();
}
inline void TextMessage::clear_channel_id() {
  channel_id_.Clear();
}
inline ::google::protobuf::uint32 TextMessage::channel_id(int index) const {
  // @@protoc_insertion_point(field_get:MumbleProto.TextMessage.channel_id)
  return channel_id_.Get(index);
}
inline void TextMessage::set_channel_id(int index, ::google::protobuf::uint32 value) {
  channel_id_.Set(index, value);
  // @@protoc_insertion_point(field_set:MumbleProto.TextMessage.channel_id)
}
inline void TextMessage::add_channel_id(::google::protobuf::uint32 value) {
  channel_id_.Add(value);
  // @@protoc_insertion_point(field_add:MumbleProto.TextMessage.channel_id)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
TextMessage::channel_id() const {
  // @@protoc_insertion_point(field_list:MumbleProto.TextMessage.channel_id)
  return channel_id_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
TextMessage::mutable_channel_id() {
  // @@protoc_insertion_point(field_mutable_list:MumbleProto.TextMessage.channel_id)
  return &channel_id_;
}

// repeated uint32 tree_id = 4;
inline int TextMessage::tree_id_size() const {
  return tree_id_.size();
}
inline void TextMessage::clear_tree_id() {
  tree_id_.Clear();
}
inline ::google::protobuf::uint32 TextMessage::tree_id(int index) const {
  // @@protoc_insertion_point(field_get:MumbleProto.TextMessage.tree_id)
  return tree_id_.Get(index);
}
inline void TextMessage::set_tree_id(int index, ::google::protobuf::uint32 value) {
  tree_id_.Set(index, value);
  // @@protoc_insertion_point(field_set:MumbleProto.TextMessage.tree_id)
}
inline void TextMessage::add_tree_id(::google::protobuf::uint32 value) {
  tree_id_.Add(value);
  // @@protoc_insertion_point(field_add:MumbleProto.TextMessage.tree_id)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
TextMessage::tree_id() const {
  // @@protoc_insertion_point(field_list:MumbleProto.TextMessage.tree_id)
  return tree_id_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
TextMessage::mutable_tree_id() {
  // @@protoc_insertion_point(field_mutable_list:MumbleProto.TextMessage.tree_id)
  return &tree_id_;
}

// required string message = 5;
inline bool TextMessage::has_message() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TextMessage::clear_message() {
  message_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::std::string& TextMessage::message() const {
  // @@protoc_insertion_point(field_get:MumbleProto.TextMessage.message)
  return message_.GetNoArena();
}
inline void TextMessage::set_message(const ::std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:MumbleProto.TextMessage.message)
}
#if LANG_CXX11
inline void TextMessage::set_message(::std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  message_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:MumbleProto.TextMessage.message)
}
#endif
inline void TextMessage::set_message(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:MumbleProto.TextMessage.message)
}
inline void TextMessage::set_message(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:MumbleProto.TextMessage.message)
}
inline ::std::string* TextMessage::mutable_message() {
  _has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_mutable:MumbleProto.TextMessage.message)
  return message_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TextMessage::release_message() {
  // @@protoc_insertion_point(field_release:MumbleProto.TextMessage.message)
  if (!has_message()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return message_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TextMessage::set_allocated_message(::std::string* message) {
  if (message != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  message_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), message);
  // @@protoc_insertion_point(field_set_allocated:MumbleProto.TextMessage.message)
}

// -------------------------------------------------------------------

// PermissionDenied

// optional uint32 permission = 1;
inline bool PermissionDenied::has_permission() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PermissionDenied::clear_permission() {
  permission_ = 0u;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::google::protobuf::uint32 PermissionDenied::permission() const {
  // @@protoc_insertion_point(field_get:MumbleProto.PermissionDenied.permission)
  return permission_;
}
inline void PermissionDenied::set_permission(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000004u;
  permission_ = value;
  // @@protoc_insertion_point(field_set:MumbleProto.PermissionDenied.permission)
}

// optional uint32 channel_id = 2;
inline bool PermissionDenied::has_channel_id() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void PermissionDenied::clear_channel_id() {
  channel_id_ = 0u;
  _has_bits_[0] &= ~0x00000008u;
}
inline ::google::protobuf::uint32 PermissionDenied::channel_id() const {
  // @@protoc_insertion_point(field_get:MumbleProto.PermissionDenied.channel_id)
  return channel_id_;
}
inline void PermissionDenied::set_channel_id(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000008u;
  channel_id_ = value;
  // @@protoc_insertion_point(field_set:MumbleProto.PermissionDenied.channel_id)
}

// optional uint32 session = 3;
inline bool PermissionDenied::has_session() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void PermissionDenied::clear_session() {
  session_ = 0u;
  _has_bits_[0] &= ~0x00000010u;
}
inline ::google::protobuf::uint32 PermissionDenied::session() const {
  // @@protoc_insertion_point(field_get:MumbleProto.PermissionDenied.session)
  return session_;
}
inline void PermissionDenied::set_session(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000010u;
  session_ = value;
  // @@protoc_insertion_point(field_set:MumbleProto.PermissionDenied.session)
}

// optional string reason = 4;
inline bool PermissionDenied::has_reason() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PermissionDenied::clear_reason() {
  reason_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::std::string& PermissionDenied::reason() const {
  // @@protoc_insertion_point(field_get:MumbleProto.PermissionDenied.reason)
  return reason_.GetNoArena();
}
inline void PermissionDenied::set_reason(const ::std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  reason_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:MumbleProto.PermissionDenied.reason)
}
#if LANG_CXX11
inline void PermissionDenied::set_reason(::std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  reason_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:MumbleProto.PermissionDenied.reason)
}
#endif
inline void PermissionDenied::set_reason(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  reason_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:MumbleProto.PermissionDenied.reason)
}
inline void PermissionDenied::set_reason(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  reason_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:MumbleProto.PermissionDenied.reason)
}
inline ::std::string* PermissionDenied::mutable_reason() {
  _has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_mutable:MumbleProto.PermissionDenied.reason)
  return reason_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* PermissionDenied::release_reason() {
  // @@protoc_insertion_point(field_release:MumbleProto.PermissionDenied.reason)
  if (!has_reason()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return reason_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void PermissionDenied::set_allocated_reason(::std::string* reason) {
  if (reason != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  reason_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), reason);
  // @@protoc_insertion_point(field_set_allocated:MumbleProto.PermissionDenied.reason)
}

// optional .MumbleProto.PermissionDenied.DenyType type = 5;
inline bool PermissionDenied::has_type() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void PermissionDenied::clear_type() {
  type_ = 0;
  _has_bits_[0] &= ~0x00000020u;
}
inline ::MumbleProto::PermissionDenied_DenyType PermissionDenied::type() const {
  // @@protoc_insertion_point(field_get:MumbleProto.PermissionDenied.type)
  return static_cast< ::MumbleProto::PermissionDenied_DenyType >(type_);
}
inline void PermissionDenied::set_type(::MumbleProto::PermissionDenied_DenyType value) {
  assert(::MumbleProto::PermissionDenied_DenyType_IsValid(value));
  _has_bits_[0] |= 0x00000020u;
  type_ = value;
  // @@protoc_insertion_point(field_set:MumbleProto.PermissionDenied.type)
}

// optional string name = 6;
inline bool PermissionDenied::has_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PermissionDenied::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::std::string& PermissionDenied::name() const {
  // @@protoc_insertion_point(field_get:MumbleProto.PermissionDenied.name)
  return name_.GetNoArena();
}
inline void PermissionDenied::set_name(const ::std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:MumbleProto.PermissionDenied.name)
}
#if LANG_CXX11
inline void PermissionDenied::set_name(::std::string&& value) {
  _has_bits_[0] |= 0x00000002u;
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:MumbleProto.PermissionDenied.name)
}
#endif
inline void PermissionDenied::set_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000002u;
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:MumbleProto.PermissionDenied.name)
}
inline void PermissionDenied::set_name(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000002u;
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:MumbleProto.PermissionDenied.name)
}
inline ::std::string* PermissionDenied::mutable_name() {
  _has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_mutable:MumbleProto.PermissionDenied.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* PermissionDenied::release_name() {
  // @@protoc_insertion_point(field_release:MumbleProto.PermissionDenied.name)
  if (!has_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return name_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void PermissionDenied::set_allocated_name(::std::string* name) {
  if (name != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:MumbleProto.PermissionDenied.name)
}

// -------------------------------------------------------------------

// ACL_ChanGroup

// required string name = 1;
inline bool ACL_ChanGroup::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ACL_ChanGroup::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::std::string& ACL_ChanGroup::name() const {
  // @@protoc_insertion_point(field_get:MumbleProto.ACL.ChanGroup.name)
  return name_.GetNoArena();
}
inline void ACL_ChanGroup::set_name(const ::std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:MumbleProto.ACL.ChanGroup.name)
}
#if LANG_CXX11
inline void ACL_ChanGroup::set_name(::std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:MumbleProto.ACL.ChanGroup.name)
}
#endif
inline void ACL_ChanGroup::set_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:MumbleProto.ACL.ChanGroup.name)
}
inline void ACL_ChanGroup::set_name(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:MumbleProto.ACL.ChanGroup.name)
}
inline ::std::string* ACL_ChanGroup::mutable_name() {
  _has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_mutable:MumbleProto.ACL.ChanGroup.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ACL_ChanGroup::release_name() {
  // @@protoc_insertion_point(field_release:MumbleProto.ACL.ChanGroup.name)
  if (!has_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return name_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ACL_ChanGroup::set_allocated_name(::std::string* name) {
  if (name != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:MumbleProto.ACL.ChanGroup.name)
}

// optional bool inherited = 2 [default = true];
inline bool ACL_ChanGroup::has_inherited() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ACL_ChanGroup::clear_inherited() {
  inherited_ = true;
  _has_bits_[0] &= ~0x00000002u;
}
inline bool ACL_ChanGroup::inherited() const {
  // @@protoc_insertion_point(field_get:MumbleProto.ACL.ChanGroup.inherited)
  return inherited_;
}
inline void ACL_ChanGroup::set_inherited(bool value) {
  _has_bits_[0] |= 0x00000002u;
  inherited_ = value;
  // @@protoc_insertion_point(field_set:MumbleProto.ACL.ChanGroup.inherited)
}

// optional bool inherit = 3 [default = true];
inline bool ACL_ChanGroup::has_inherit() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ACL_ChanGroup::clear_inherit() {
  inherit_ = true;
  _has_bits_[0] &= ~0x00000004u;
}
inline bool ACL_ChanGroup::inherit() const {
  // @@protoc_insertion_point(field_get:MumbleProto.ACL.ChanGroup.inherit)
  return inherit_;
}
inline void ACL_ChanGroup::set_inherit(bool value) {
  _has_bits_[0] |= 0x00000004u;
  inherit_ = value;
  // @@protoc_insertion_point(field_set:MumbleProto.ACL.ChanGroup.inherit)
}

// optional bool inheritable = 4 [default = true];
inline bool ACL_ChanGroup::has_inheritable() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ACL_ChanGroup::clear_inheritable() {
  inheritable_ = true;
  _has_bits_[0] &= ~0x00000008u;
}
inline bool ACL_ChanGroup::inheritable() const {
  // @@protoc_insertion_point(field_get:MumbleProto.ACL.ChanGroup.inheritable)
  return inheritable_;
}
inline void ACL_ChanGroup::set_inheritable(bool value) {
  _has_bits_[0] |= 0x00000008u;
  inheritable_ = value;
  // @@protoc_insertion_point(field_set:MumbleProto.ACL.ChanGroup.inheritable)
}

// repeated uint32 add = 5;
inline int ACL_ChanGroup::add_size() const {
  return add_.size();
}
inline void ACL_ChanGroup::clear_add() {
  add_.Clear();
}
inline ::google::protobuf::uint32 ACL_ChanGroup::add(int index) const {
  // @@protoc_insertion_point(field_get:MumbleProto.ACL.ChanGroup.add)
  return add_.Get(index);
}
inline void ACL_ChanGroup::set_add(int index, ::google::protobuf::uint32 value) {
  add_.Set(index, value);
  // @@protoc_insertion_point(field_set:MumbleProto.ACL.ChanGroup.add)
}
inline void ACL_ChanGroup::add_add(::google::protobuf::uint32 value) {
  add_.Add(value);
  // @@protoc_insertion_point(field_add:MumbleProto.ACL.ChanGroup.add)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
ACL_ChanGroup::add() const {
  // @@protoc_insertion_point(field_list:MumbleProto.ACL.ChanGroup.add)
  return add_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
ACL_ChanGroup::mutable_add() {
  // @@protoc_insertion_point(field_mutable_list:MumbleProto.ACL.ChanGroup.add)
  return &add_;
}

// repeated uint32 remove = 6;
inline int ACL_ChanGroup::remove_size() const {
  return remove_.size();
}
inline void ACL_ChanGroup::clear_remove() {
  remove_.Clear();
}
inline ::google::protobuf::uint32 ACL_ChanGroup::remove(int index) const {
  // @@protoc_insertion_point(field_get:MumbleProto.ACL.ChanGroup.remove)
  return remove_.Get(index);
}
inline void ACL_ChanGroup::set_remove(int index, ::google::protobuf::uint32 value) {
  remove_.Set(index, value);
  // @@protoc_insertion_point(field_set:MumbleProto.ACL.ChanGroup.remove)
}
inline void ACL_ChanGroup::add_remove(::google::protobuf::uint32 value) {
  remove_.Add(value);
  // @@protoc_insertion_point(field_add:MumbleProto.ACL.ChanGroup.remove)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
ACL_ChanGroup::remove() const {
  // @@protoc_insertion_point(field_list:MumbleProto.ACL.ChanGroup.remove)
  return remove_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
ACL_ChanGroup::mutable_remove() {
  // @@protoc_insertion_point(field_mutable_list:MumbleProto.ACL.ChanGroup.remove)
  return &remove_;
}

// repeated uint32 inherited_members = 7;
inline int ACL_ChanGroup::inherited_members_size() const {
  return inherited_members_.size();
}
inline void ACL_ChanGroup::clear_inherited_members() {
  inherited_members_.Clear();
}
inline ::google::protobuf::uint32 ACL_ChanGroup::inherited_members(int index) const {
  // @@protoc_insertion_point(field_get:MumbleProto.ACL.ChanGroup.inherited_members)
  return inherited_members_.Get(index);
}
inline void ACL_ChanGroup::set_inherited_members(int index, ::google::protobuf::uint32 value) {
  inherited_members_.Set(index, value);
  // @@protoc_insertion_point(field_set:MumbleProto.ACL.ChanGroup.inherited_members)
}
inline void ACL_ChanGroup::add_inherited_members(::google::protobuf::uint32 value) {
  inherited_members_.Add(value);
  // @@protoc_insertion_point(field_add:MumbleProto.ACL.ChanGroup.inherited_members)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
ACL_ChanGroup::inherited_members() const {
  // @@protoc_insertion_point(field_list:MumbleProto.ACL.ChanGroup.inherited_members)
  return inherited_members_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
ACL_ChanGroup::mutable_inherited_members() {
  // @@protoc_insertion_point(field_mutable_list:MumbleProto.ACL.ChanGroup.inherited_members)
  return &inherited_members_;
}

// -------------------------------------------------------------------

// ACL_ChanACL

// optional bool apply_here = 1 [default = true];
inline bool ACL_ChanACL::has_apply_here() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ACL_ChanACL::clear_apply_here() {
  apply_here_ = true;
  _has_bits_[0] &= ~0x00000010u;
}
inline bool ACL_ChanACL::apply_here() const {
  // @@protoc_insertion_point(field_get:MumbleProto.ACL.ChanACL.apply_here)
  return apply_here_;
}
inline void ACL_ChanACL::set_apply_here(bool value) {
  _has_bits_[0] |= 0x00000010u;
  apply_here_ = value;
  // @@protoc_insertion_point(field_set:MumbleProto.ACL.ChanACL.apply_here)
}

// optional bool apply_subs = 2 [default = true];
inline bool ACL_ChanACL::has_apply_subs() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ACL_ChanACL::clear_apply_subs() {
  apply_subs_ = true;
  _has_bits_[0] &= ~0x00000020u;
}
inline bool ACL_ChanACL::apply_subs() const {
  // @@protoc_insertion_point(field_get:MumbleProto.ACL.ChanACL.apply_subs)
  return apply_subs_;
}
inline void ACL_ChanACL::set_apply_subs(bool value) {
  _has_bits_[0] |= 0x00000020u;
  apply_subs_ = value;
  // @@protoc_insertion_point(field_set:MumbleProto.ACL.ChanACL.apply_subs)
}

// optional bool inherited = 3 [default = true];
inline bool ACL_ChanACL::has_inherited() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void ACL_ChanACL::clear_inherited() {
  inherited_ = true;
  _has_bits_[0] &= ~0x00000040u;
}
inline bool ACL_ChanACL::inherited() const {
  // @@protoc_insertion_point(field_get:MumbleProto.ACL.ChanACL.inherited)
  return inherited_;
}
inline void ACL_ChanACL::set_inherited(bool value) {
  _has_bits_[0] |= 0x00000040u;
  inherited_ = value;
  // @@protoc_insertion_point(field_set:MumbleProto.ACL.ChanACL.inherited)
}

// optional uint32 user_id = 4;
inline bool ACL_ChanACL::has_user_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ACL_ChanACL::clear_user_id() {
  user_id_ = 0u;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::google::protobuf::uint32 ACL_ChanACL::user_id() const {
  // @@protoc_insertion_point(field_get:MumbleProto.ACL.ChanACL.user_id)
  return user_id_;
}
inline void ACL_ChanACL::set_user_id(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000002u;
  user_id_ = value;
  // @@protoc_insertion_point(field_set:MumbleProto.ACL.ChanACL.user_id)
}

// optional string group = 5;
inline bool ACL_ChanACL::has_group() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ACL_ChanACL::clear_group() {
  group_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::std::string& ACL_ChanACL::group() const {
  // @@protoc_insertion_point(field_get:MumbleProto.ACL.ChanACL.group)
  return group_.GetNoArena();
}
inline void ACL_ChanACL::set_group(const ::std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  group_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:MumbleProto.ACL.ChanACL.group)
}
#if LANG_CXX11
inline void ACL_ChanACL::set_group(::std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  group_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:MumbleProto.ACL.ChanACL.group)
}
#endif
inline void ACL_ChanACL::set_group(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  group_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:MumbleProto.ACL.ChanACL.group)
}
inline void ACL_ChanACL::set_group(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  group_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:MumbleProto.ACL.ChanACL.group)
}
inline ::std::string* ACL_ChanACL::mutable_group() {
  _has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_mutable:MumbleProto.ACL.ChanACL.group)
  return group_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ACL_ChanACL::release_group() {
  // @@protoc_insertion_point(field_release:MumbleProto.ACL.ChanACL.group)
  if (!has_group()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return group_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ACL_ChanACL::set_allocated_group(::std::string* group) {
  if (group != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  group_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), group);
  // @@protoc_insertion_point(field_set_allocated:MumbleProto.ACL.ChanACL.group)
}

// optional uint32 grant = 6;
inline bool ACL_ChanACL::has_grant() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ACL_ChanACL::clear_grant() {
  grant_ = 0u;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::google::protobuf::uint32 ACL_ChanACL::grant() const {
  // @@protoc_insertion_point(field_get:MumbleProto.ACL.ChanACL.grant)
  return grant_;
}
inline void ACL_ChanACL::set_grant(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000004u;
  grant_ = value;
  // @@protoc_insertion_point(field_set:MumbleProto.ACL.ChanACL.grant)
}

// optional uint32 deny = 7;
inline bool ACL_ChanACL::has_deny() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ACL_ChanACL::clear_deny() {
  deny_ = 0u;
  _has_bits_[0] &= ~0x00000008u;
}
inline ::google::protobuf::uint32 ACL_ChanACL::deny() const {
  // @@protoc_insertion_point(field_get:MumbleProto.ACL.ChanACL.deny)
  return deny_;
}
inline void ACL_ChanACL::set_deny(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000008u;
  deny_ = value;
  // @@protoc_insertion_point(field_set:MumbleProto.ACL.ChanACL.deny)
}

// -------------------------------------------------------------------

// ACL

// required uint32 channel_id = 1;
inline bool ACL::has_channel_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ACL::clear_channel_id() {
  channel_id_ = 0u;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::google::protobuf::uint32 ACL::channel_id() const {
  // @@protoc_insertion_point(field_get:MumbleProto.ACL.channel_id)
  return channel_id_;
}
inline void ACL::set_channel_id(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000001u;
  channel_id_ = value;
  // @@protoc_insertion_point(field_set:MumbleProto.ACL.channel_id)
}

// optional bool inherit_acls = 2 [default = true];
inline bool ACL::has_inherit_acls() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ACL::clear_inherit_acls() {
  inherit_acls_ = true;
  _has_bits_[0] &= ~0x00000004u;
}
inline bool ACL::inherit_acls() const {
  // @@protoc_insertion_point(field_get:MumbleProto.ACL.inherit_acls)
  return inherit_acls_;
}
inline void ACL::set_inherit_acls(bool value) {
  _has_bits_[0] |= 0x00000004u;
  inherit_acls_ = value;
  // @@protoc_insertion_point(field_set:MumbleProto.ACL.inherit_acls)
}

// repeated .MumbleProto.ACL.ChanGroup groups = 3;
inline int ACL::groups_size() const {
  return groups_.size();
}
inline void ACL::clear_groups() {
  groups_.Clear();
}
inline ::MumbleProto::ACL_ChanGroup* ACL::mutable_groups(int index) {
  // @@protoc_insertion_point(field_mutable:MumbleProto.ACL.groups)
  return groups_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::MumbleProto::ACL_ChanGroup >*
ACL::mutable_groups() {
  // @@protoc_insertion_point(field_mutable_list:MumbleProto.ACL.groups)
  return &groups_;
}
inline const ::MumbleProto::ACL_ChanGroup& ACL::groups(int index) const {
  // @@protoc_insertion_point(field_get:MumbleProto.ACL.groups)
  return groups_.Get(index);
}
inline ::MumbleProto::ACL_ChanGroup* ACL::add_groups() {
  // @@protoc_insertion_point(field_add:MumbleProto.ACL.groups)
  return groups_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::MumbleProto::ACL_ChanGroup >&
ACL::groups() const {
  // @@protoc_insertion_point(field_list:MumbleProto.ACL.groups)
  return groups_;
}

// repeated .MumbleProto.ACL.ChanACL acls = 4;
inline int ACL::acls_size() const {
  return acls_.size();
}
inline void ACL::clear_acls() {
  acls_.Clear();
}
inline ::MumbleProto::ACL_ChanACL* ACL::mutable_acls(int index) {
  // @@protoc_insertion_point(field_mutable:MumbleProto.ACL.acls)
  return acls_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::MumbleProto::ACL_ChanACL >*
ACL::mutable_acls() {
  // @@protoc_insertion_point(field_mutable_list:MumbleProto.ACL.acls)
  return &acls_;
}
inline const ::MumbleProto::ACL_ChanACL& ACL::acls(int index) const {
  // @@protoc_insertion_point(field_get:MumbleProto.ACL.acls)
  return acls_.Get(index);
}
inline ::MumbleProto::ACL_ChanACL* ACL::add_acls() {
  // @@protoc_insertion_point(field_add:MumbleProto.ACL.acls)
  return acls_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::MumbleProto::ACL_ChanACL >&
ACL::acls() const {
  // @@protoc_insertion_point(field_list:MumbleProto.ACL.acls)
  return acls_;
}

// optional bool query = 5 [default = false];
inline bool ACL::has_query() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ACL::clear_query() {
  query_ = false;
  _has_bits_[0] &= ~0x00000002u;
}
inline bool ACL::query() const {
  // @@protoc_insertion_point(field_get:MumbleProto.ACL.query)
  return query_;
}
inline void ACL::set_query(bool value) {
  _has_bits_[0] |= 0x00000002u;
  query_ = value;
  // @@protoc_insertion_point(field_set:MumbleProto.ACL.query)
}

// -------------------------------------------------------------------

// QueryUsers

// repeated uint32 ids = 1;
inline int QueryUsers::ids_size() const {
  return ids_.size();
}
inline void QueryUsers::clear_ids() {
  ids_.Clear();
}
inline ::google::protobuf::uint32 QueryUsers::ids(int index) const {
  // @@protoc_insertion_point(field_get:MumbleProto.QueryUsers.ids)
  return ids_.Get(index);
}
inline void QueryUsers::set_ids(int index, ::google::protobuf::uint32 value) {
  ids_.Set(index, value);
  // @@protoc_insertion_point(field_set:MumbleProto.QueryUsers.ids)
}
inline void QueryUsers::add_ids(::google::protobuf::uint32 value) {
  ids_.Add(value);
  // @@protoc_insertion_point(field_add:MumbleProto.QueryUsers.ids)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
QueryUsers::ids() const {
  // @@protoc_insertion_point(field_list:MumbleProto.QueryUsers.ids)
  return ids_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
QueryUsers::mutable_ids() {
  // @@protoc_insertion_point(field_mutable_list:MumbleProto.QueryUsers.ids)
  return &ids_;
}

// repeated string names = 2;
inline int QueryUsers::names_size() const {
  return names_.size();
}
inline void QueryUsers::clear_names() {
  names_.Clear();
}
inline const ::std::string& QueryUsers::names(int index) const {
  // @@protoc_insertion_point(field_get:MumbleProto.QueryUsers.names)
  return names_.Get(index);
}
inline ::std::string* QueryUsers::mutable_names(int index) {
  // @@protoc_insertion_point(field_mutable:MumbleProto.QueryUsers.names)
  return names_.Mutable(index);
}
inline void QueryUsers::set_names(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:MumbleProto.QueryUsers.names)
  names_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void QueryUsers::set_names(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:MumbleProto.QueryUsers.names)
  names_.Mutable(index)->assign(std::move(value));
}
#endif
inline void QueryUsers::set_names(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  names_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:MumbleProto.QueryUsers.names)
}
inline void QueryUsers::set_names(int index, const char* value, size_t size) {
  names_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:MumbleProto.QueryUsers.names)
}
inline ::std::string* QueryUsers::add_names() {
  // @@protoc_insertion_point(field_add_mutable:MumbleProto.QueryUsers.names)
  return names_.Add();
}
inline void QueryUsers::add_names(const ::std::string& value) {
  names_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:MumbleProto.QueryUsers.names)
}
#if LANG_CXX11
inline void QueryUsers::add_names(::std::string&& value) {
  names_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:MumbleProto.QueryUsers.names)
}
#endif
inline void QueryUsers::add_names(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  names_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:MumbleProto.QueryUsers.names)
}
inline void QueryUsers::add_names(const char* value, size_t size) {
  names_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:MumbleProto.QueryUsers.names)
}
inline const ::google::protobuf::RepeatedPtrField<::std::string>&
QueryUsers::names() const {
  // @@protoc_insertion_point(field_list:MumbleProto.QueryUsers.names)
  return names_;
}
inline ::google::protobuf::RepeatedPtrField<::std::string>*
QueryUsers::mutable_names() {
  // @@protoc_insertion_point(field_mutable_list:MumbleProto.QueryUsers.names)
  return &names_;
}

// -------------------------------------------------------------------

// CryptSetup

// optional bytes key = 1;
inline bool CryptSetup::has_key() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CryptSetup::clear_key() {
  key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::std::string& CryptSetup::key() const {
  // @@protoc_insertion_point(field_get:MumbleProto.CryptSetup.key)
  return key_.GetNoArena();
}
inline void CryptSetup::set_key(const ::std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:MumbleProto.CryptSetup.key)
}
#if LANG_CXX11
inline void CryptSetup::set_key(::std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  key_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:MumbleProto.CryptSetup.key)
}
#endif
inline void CryptSetup::set_key(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:MumbleProto.CryptSetup.key)
}
inline void CryptSetup::set_key(const void* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:MumbleProto.CryptSetup.key)
}
inline ::std::string* CryptSetup::mutable_key() {
  _has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_mutable:MumbleProto.CryptSetup.key)
  return key_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CryptSetup::release_key() {
  // @@protoc_insertion_point(field_release:MumbleProto.CryptSetup.key)
  if (!has_key()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return key_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CryptSetup::set_allocated_key(::std::string* key) {
  if (key != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  key_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), key);
  // @@protoc_insertion_point(field_set_allocated:MumbleProto.CryptSetup.key)
}

// optional bytes client_nonce = 2;
inline bool CryptSetup::has_client_nonce() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CryptSetup::clear_client_nonce() {
  client_nonce_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::std::string& CryptSetup::client_nonce() const {
  // @@protoc_insertion_point(field_get:MumbleProto.CryptSetup.client_nonce)
  return client_nonce_.GetNoArena();
}
inline void CryptSetup::set_client_nonce(const ::std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  client_nonce_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:MumbleProto.CryptSetup.client_nonce)
}
#if LANG_CXX11
inline void CryptSetup::set_client_nonce(::std::string&& value) {
  _has_bits_[0] |= 0x00000002u;
  client_nonce_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:MumbleProto.CryptSetup.client_nonce)
}
#endif
inline void CryptSetup::set_client_nonce(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000002u;
  client_nonce_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:MumbleProto.CryptSetup.client_nonce)
}
inline void CryptSetup::set_client_nonce(const void* value, size_t size) {
  _has_bits_[0] |= 0x00000002u;
  client_nonce_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:MumbleProto.CryptSetup.client_nonce)
}
inline ::std::string* CryptSetup::mutable_client_nonce() {
  _has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_mutable:MumbleProto.CryptSetup.client_nonce)
  return client_nonce_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CryptSetup::release_client_nonce() {
  // @@protoc_insertion_point(field_release:MumbleProto.CryptSetup.client_nonce)
  if (!has_client_nonce()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return client_nonce_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CryptSetup::set_allocated_client_nonce(::std::string* client_nonce) {
  if (client_nonce != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  client_nonce_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), client_nonce);
  // @@protoc_insertion_point(field_set_allocated:MumbleProto.CryptSetup.client_nonce)
}

// optional bytes server_nonce = 3;
inline bool CryptSetup::has_server_nonce() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CryptSetup::clear_server_nonce() {
  server_nonce_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000004u;
}
inline const ::std::string& CryptSetup::server_nonce() const {
  // @@protoc_insertion_point(field_get:MumbleProto.CryptSetup.server_nonce)
  return server_nonce_.GetNoArena();
}
inline void CryptSetup::set_server_nonce(const ::std::string& value) {
  _has_bits_[0] |= 0x00000004u;
  server_nonce_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:MumbleProto.CryptSetup.server_nonce)
}
#if LANG_CXX11
inline void CryptSetup::set_server_nonce(::std::string&& value) {
  _has_bits_[0] |= 0x00000004u;
  server_nonce_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:MumbleProto.CryptSetup.server_nonce)
}
#endif
inline void CryptSetup::set_server_nonce(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000004u;
  server_nonce_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:MumbleProto.CryptSetup.server_nonce)
}
inline void CryptSetup::set_server_nonce(const void* value, size_t size) {
  _has_bits_[0] |= 0x00000004u;
  server_nonce_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:MumbleProto.CryptSetup.server_nonce)
}
inline ::std::string* CryptSetup::mutable_server_nonce() {
  _has_bits_[0] |= 0x00000004u;
  // @@protoc_insertion_point(field_mutable:MumbleProto.CryptSetup.server_nonce)
  return server_nonce_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CryptSetup::release_server_nonce() {
  // @@protoc_insertion_point(field_release:MumbleProto.CryptSetup.server_nonce)
  if (!has_server_nonce()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000004u;
  return server_nonce_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CryptSetup::set_allocated_server_nonce(::std::string* server_nonce) {
  if (server_nonce != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  server_nonce_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), server_nonce);
  // @@protoc_insertion_point(field_set_allocated:MumbleProto.CryptSetup.server_nonce)
}

// -------------------------------------------------------------------

// ContextActionModify

// required string action = 1;
inline bool ContextActionModify::has_action() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ContextActionModify::clear_action() {
  action_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::std::string& ContextActionModify::action() const {
  // @@protoc_insertion_point(field_get:MumbleProto.ContextActionModify.action)
  return action_.GetNoArena();
}
inline void ContextActionModify::set_action(const ::std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  action_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:MumbleProto.ContextActionModify.action)
}
#if LANG_CXX11
inline void ContextActionModify::set_action(::std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  action_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:MumbleProto.ContextActionModify.action)
}
#endif
inline void ContextActionModify::set_action(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  action_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:MumbleProto.ContextActionModify.action)
}
inline void ContextActionModify::set_action(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  action_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:MumbleProto.ContextActionModify.action)
}
inline ::std::string* ContextActionModify::mutable_action() {
  _has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_mutable:MumbleProto.ContextActionModify.action)
  return action_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ContextActionModify::release_action() {
  // @@protoc_insertion_point(field_release:MumbleProto.ContextActionModify.action)
  if (!has_action()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return action_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ContextActionModify::set_allocated_action(::std::string* action) {
  if (action != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  action_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), action);
  // @@protoc_insertion_point(field_set_allocated:MumbleProto.ContextActionModify.action)
}

// optional string text = 2;
inline bool ContextActionModify::has_text() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ContextActionModify::clear_text() {
  text_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::std::string& ContextActionModify::text() const {
  // @@protoc_insertion_point(field_get:MumbleProto.ContextActionModify.text)
  return text_.GetNoArena();
}
inline void ContextActionModify::set_text(const ::std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  text_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:MumbleProto.ContextActionModify.text)
}
#if LANG_CXX11
inline void ContextActionModify::set_text(::std::string&& value) {
  _has_bits_[0] |= 0x00000002u;
  text_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:MumbleProto.ContextActionModify.text)
}
#endif
inline void ContextActionModify::set_text(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000002u;
  text_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:MumbleProto.ContextActionModify.text)
}
inline void ContextActionModify::set_text(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000002u;
  text_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:MumbleProto.ContextActionModify.text)
}
inline ::std::string* ContextActionModify::mutable_text() {
  _has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_mutable:MumbleProto.ContextActionModify.text)
  return text_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ContextActionModify::release_text() {
  // @@protoc_insertion_point(field_release:MumbleProto.ContextActionModify.text)
  if (!has_text()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return text_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ContextActionModify::set_allocated_text(::std::string* text) {
  if (text != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  text_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), text);
  // @@protoc_insertion_point(field_set_allocated:MumbleProto.ContextActionModify.text)
}

// optional uint32 context = 3;
inline bool ContextActionModify::has_context() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ContextActionModify::clear_context() {
  context_ = 0u;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::google::protobuf::uint32 ContextActionModify::context() const {
  // @@protoc_insertion_point(field_get:MumbleProto.ContextActionModify.context)
  return context_;
}
inline void ContextActionModify::set_context(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000004u;
  context_ = value;
  // @@protoc_insertion_point(field_set:MumbleProto.ContextActionModify.context)
}

// optional .MumbleProto.ContextActionModify.Operation operation = 4;
inline bool ContextActionModify::has_operation() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ContextActionModify::clear_operation() {
  operation_ = 0;
  _has_bits_[0] &= ~0x00000008u;
}
inline ::MumbleProto::ContextActionModify_Operation ContextActionModify::operation() const {
  // @@protoc_insertion_point(field_get:MumbleProto.ContextActionModify.operation)
  return static_cast< ::MumbleProto::ContextActionModify_Operation >(operation_);
}
inline void ContextActionModify::set_operation(::MumbleProto::ContextActionModify_Operation value) {
  assert(::MumbleProto::ContextActionModify_Operation_IsValid(value));
  _has_bits_[0] |= 0x00000008u;
  operation_ = value;
  // @@protoc_insertion_point(field_set:MumbleProto.ContextActionModify.operation)
}

// -------------------------------------------------------------------

// ContextAction

// optional uint32 session = 1;
inline bool ContextAction::has_session() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ContextAction::clear_session() {
  session_ = 0u;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::google::protobuf::uint32 ContextAction::session() const {
  // @@protoc_insertion_point(field_get:MumbleProto.ContextAction.session)
  return session_;
}
inline void ContextAction::set_session(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000002u;
  session_ = value;
  // @@protoc_insertion_point(field_set:MumbleProto.ContextAction.session)
}

// optional uint32 channel_id = 2;
inline bool ContextAction::has_channel_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ContextAction::clear_channel_id() {
  channel_id_ = 0u;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::google::protobuf::uint32 ContextAction::channel_id() const {
  // @@protoc_insertion_point(field_get:MumbleProto.ContextAction.channel_id)
  return channel_id_;
}
inline void ContextAction::set_channel_id(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000004u;
  channel_id_ = value;
  // @@protoc_insertion_point(field_set:MumbleProto.ContextAction.channel_id)
}

// required string action = 3;
inline bool ContextAction::has_action() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ContextAction::clear_action() {
  action_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::std::string& ContextAction::action() const {
  // @@protoc_insertion_point(field_get:MumbleProto.ContextAction.action)
  return action_.GetNoArena();
}
inline void ContextAction::set_action(const ::std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  action_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:MumbleProto.ContextAction.action)
}
#if LANG_CXX11
inline void ContextAction::set_action(::std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  action_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:MumbleProto.ContextAction.action)
}
#endif
inline void ContextAction::set_action(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  action_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:MumbleProto.ContextAction.action)
}
inline void ContextAction::set_action(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  action_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:MumbleProto.ContextAction.action)
}
inline ::std::string* ContextAction::mutable_action() {
  _has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_mutable:MumbleProto.ContextAction.action)
  return action_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ContextAction::release_action() {
  // @@protoc_insertion_point(field_release:MumbleProto.ContextAction.action)
  if (!has_action()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return action_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ContextAction::set_allocated_action(::std::string* action) {
  if (action != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  action_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), action);
  // @@protoc_insertion_point(field_set_allocated:MumbleProto.ContextAction.action)
}

// -------------------------------------------------------------------

// UserList_User

// required uint32 user_id = 1;
inline bool UserList_User::has_user_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UserList_User::clear_user_id() {
  user_id_ = 0u;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::google::protobuf::uint32 UserList_User::user_id() const {
  // @@protoc_insertion_point(field_get:MumbleProto.UserList.User.user_id)
  return user_id_;
}
inline void UserList_User::set_user_id(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000002u;
  user_id_ = value;
  // @@protoc_insertion_point(field_set:MumbleProto.UserList.User.user_id)
}

// optional string name = 2;
inline bool UserList_User::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UserList_User::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::std::string& UserList_User::name() const {
  // @@protoc_insertion_point(field_get:MumbleProto.UserList.User.name)
  return name_.GetNoArena();
}
inline void UserList_User::set_name(const ::std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:MumbleProto.UserList.User.name)
}
#if LANG_CXX11
inline void UserList_User::set_name(::std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:MumbleProto.UserList.User.name)
}
#endif
inline void UserList_User::set_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:MumbleProto.UserList.User.name)
}
inline void UserList_User::set_name(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:MumbleProto.UserList.User.name)
}
inline ::std::string* UserList_User::mutable_name() {
  _has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_mutable:MumbleProto.UserList.User.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* UserList_User::release_name() {
  // @@protoc_insertion_point(field_release:MumbleProto.UserList.User.name)
  if (!has_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return name_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void UserList_User::set_allocated_name(::std::string* name) {
  if (name != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:MumbleProto.UserList.User.name)
}

// -------------------------------------------------------------------

// UserList

// repeated .MumbleProto.UserList.User users = 1;
inline int UserList::users_size() const {
  return users_.size();
}
inline void UserList::clear_users() {
  users_.Clear();
}
inline ::MumbleProto::UserList_User* UserList::mutable_users(int index) {
  // @@protoc_insertion_point(field_mutable:MumbleProto.UserList.users)
  return users_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::MumbleProto::UserList_User >*
UserList::mutable_users() {
  // @@protoc_insertion_point(field_mutable_list:MumbleProto.UserList.users)
  return &users_;
}
inline const ::MumbleProto::UserList_User& UserList::users(int index) const {
  // @@protoc_insertion_point(field_get:MumbleProto.UserList.users)
  return users_.Get(index);
}
inline ::MumbleProto::UserList_User* UserList::add_users() {
  // @@protoc_insertion_point(field_add:MumbleProto.UserList.users)
  return users_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::MumbleProto::UserList_User >&
UserList::users() const {
  // @@protoc_insertion_point(field_list:MumbleProto.UserList.users)
  return users_;
}

// -------------------------------------------------------------------

// VoiceTarget_Target

// repeated uint32 session = 1;
inline int VoiceTarget_Target::session_size() const {
  return session_.size();
}
inline void VoiceTarget_Target::clear_session() {
  session_.Clear();
}
inline ::google::protobuf::uint32 VoiceTarget_Target::session(int index) const {
  // @@protoc_insertion_point(field_get:MumbleProto.VoiceTarget.Target.session)
  return session_.Get(index);
}
inline void VoiceTarget_Target::set_session(int index, ::google::protobuf::uint32 value) {
  session_.Set(index, value);
  // @@protoc_insertion_point(field_set:MumbleProto.VoiceTarget.Target.session)
}
inline void VoiceTarget_Target::add_session(::google::protobuf::uint32 value) {
  session_.Add(value);
  // @@protoc_insertion_point(field_add:MumbleProto.VoiceTarget.Target.session)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
VoiceTarget_Target::session() const {
  // @@protoc_insertion_point(field_list:MumbleProto.VoiceTarget.Target.session)
  return session_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
VoiceTarget_Target::mutable_session() {
  // @@protoc_insertion_point(field_mutable_list:MumbleProto.VoiceTarget.Target.session)
  return &session_;
}

// optional uint32 channel_id = 2;
inline bool VoiceTarget_Target::has_channel_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void VoiceTarget_Target::clear_channel_id() {
  channel_id_ = 0u;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::google::protobuf::uint32 VoiceTarget_Target::channel_id() const {
  // @@protoc_insertion_point(field_get:MumbleProto.VoiceTarget.Target.channel_id)
  return channel_id_;
}
inline void VoiceTarget_Target::set_channel_id(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000002u;
  channel_id_ = value;
  // @@protoc_insertion_point(field_set:MumbleProto.VoiceTarget.Target.channel_id)
}

// optional string group = 3;
inline bool VoiceTarget_Target::has_group() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void VoiceTarget_Target::clear_group() {
  group_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::std::string& VoiceTarget_Target::group() const {
  // @@protoc_insertion_point(field_get:MumbleProto.VoiceTarget.Target.group)
  return group_.GetNoArena();
}
inline void VoiceTarget_Target::set_group(const ::std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  group_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:MumbleProto.VoiceTarget.Target.group)
}
#if LANG_CXX11
inline void VoiceTarget_Target::set_group(::std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  group_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:MumbleProto.VoiceTarget.Target.group)
}
#endif
inline void VoiceTarget_Target::set_group(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  group_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:MumbleProto.VoiceTarget.Target.group)
}
inline void VoiceTarget_Target::set_group(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  group_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:MumbleProto.VoiceTarget.Target.group)
}
inline ::std::string* VoiceTarget_Target::mutable_group() {
  _has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_mutable:MumbleProto.VoiceTarget.Target.group)
  return group_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* VoiceTarget_Target::release_group() {
  // @@protoc_insertion_point(field_release:MumbleProto.VoiceTarget.Target.group)
  if (!has_group()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return group_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void VoiceTarget_Target::set_allocated_group(::std::string* group) {
  if (group != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  group_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), group);
  // @@protoc_insertion_point(field_set_allocated:MumbleProto.VoiceTarget.Target.group)
}

// optional bool links = 4 [default = false];
inline bool VoiceTarget_Target::has_links() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void VoiceTarget_Target::clear_links() {
  links_ = false;
  _has_bits_[0] &= ~0x00000004u;
}
inline bool VoiceTarget_Target::links() const {
  // @@protoc_insertion_point(field_get:MumbleProto.VoiceTarget.Target.links)
  return links_;
}
inline void VoiceTarget_Target::set_links(bool value) {
  _has_bits_[0] |= 0x00000004u;
  links_ = value;
  // @@protoc_insertion_point(field_set:MumbleProto.VoiceTarget.Target.links)
}

// optional bool children = 5 [default = false];
inline bool VoiceTarget_Target::has_children() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void VoiceTarget_Target::clear_children() {
  children_ = false;
  _has_bits_[0] &= ~0x00000008u;
}
inline bool VoiceTarget_Target::children() const {
  // @@protoc_insertion_point(field_get:MumbleProto.VoiceTarget.Target.children)
  return children_;
}
inline void VoiceTarget_Target::set_children(bool value) {
  _has_bits_[0] |= 0x00000008u;
  children_ = value;
  // @@protoc_insertion_point(field_set:MumbleProto.VoiceTarget.Target.children)
}

// -------------------------------------------------------------------

// VoiceTarget

// optional uint32 id = 1;
inline bool VoiceTarget::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void VoiceTarget::clear_id() {
  id_ = 0u;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::google::protobuf::uint32 VoiceTarget::id() const {
  // @@protoc_insertion_point(field_get:MumbleProto.VoiceTarget.id)
  return id_;
}
inline void VoiceTarget::set_id(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000001u;
  id_ = value;
  // @@protoc_insertion_point(field_set:MumbleProto.VoiceTarget.id)
}

// repeated .MumbleProto.VoiceTarget.Target targets = 2;
inline int VoiceTarget::targets_size() const {
  return targets_.size();
}
inline void VoiceTarget::clear_targets() {
  targets_.Clear();
}
inline ::MumbleProto::VoiceTarget_Target* VoiceTarget::mutable_targets(int index) {
  // @@protoc_insertion_point(field_mutable:MumbleProto.VoiceTarget.targets)
  return targets_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::MumbleProto::VoiceTarget_Target >*
VoiceTarget::mutable_targets() {
  // @@protoc_insertion_point(field_mutable_list:MumbleProto.VoiceTarget.targets)
  return &targets_;
}
inline const ::MumbleProto::VoiceTarget_Target& VoiceTarget::targets(int index) const {
  // @@protoc_insertion_point(field_get:MumbleProto.VoiceTarget.targets)
  return targets_.Get(index);
}
inline ::MumbleProto::VoiceTarget_Target* VoiceTarget::add_targets() {
  // @@protoc_insertion_point(field_add:MumbleProto.VoiceTarget.targets)
  return targets_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::MumbleProto::VoiceTarget_Target >&
VoiceTarget::targets() const {
  // @@protoc_insertion_point(field_list:MumbleProto.VoiceTarget.targets)
  return targets_;
}

// -------------------------------------------------------------------

// PermissionQuery

// optional uint32 channel_id = 1;
inline bool PermissionQuery::has_channel_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PermissionQuery::clear_channel_id() {
  channel_id_ = 0u;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::google::protobuf::uint32 PermissionQuery::channel_id() const {
  // @@protoc_insertion_point(field_get:MumbleProto.PermissionQuery.channel_id)
  return channel_id_;
}
inline void PermissionQuery::set_channel_id(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000001u;
  channel_id_ = value;
  // @@protoc_insertion_point(field_set:MumbleProto.PermissionQuery.channel_id)
}

// optional uint32 permissions = 2;
inline bool PermissionQuery::has_permissions() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PermissionQuery::clear_permissions() {
  permissions_ = 0u;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::google::protobuf::uint32 PermissionQuery::permissions() const {
  // @@protoc_insertion_point(field_get:MumbleProto.PermissionQuery.permissions)
  return permissions_;
}
inline void PermissionQuery::set_permissions(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000002u;
  permissions_ = value;
  // @@protoc_insertion_point(field_set:MumbleProto.PermissionQuery.permissions)
}

// optional bool flush = 3 [default = false];
inline bool PermissionQuery::has_flush() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PermissionQuery::clear_flush() {
  flush_ = false;
  _has_bits_[0] &= ~0x00000004u;
}
inline bool PermissionQuery::flush() const {
  // @@protoc_insertion_point(field_get:MumbleProto.PermissionQuery.flush)
  return flush_;
}
inline void PermissionQuery::set_flush(bool value) {
  _has_bits_[0] |= 0x00000004u;
  flush_ = value;
  // @@protoc_insertion_point(field_set:MumbleProto.PermissionQuery.flush)
}

// -------------------------------------------------------------------

// CodecVersion

// required int32 alpha = 1;
inline bool CodecVersion::has_alpha() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CodecVersion::clear_alpha() {
  alpha_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::google::protobuf::int32 CodecVersion::alpha() const {
  // @@protoc_insertion_point(field_get:MumbleProto.CodecVersion.alpha)
  return alpha_;
}
inline void CodecVersion::set_alpha(::google::protobuf::int32 value) {
  _has_bits_[0] |= 0x00000001u;
  alpha_ = value;
  // @@protoc_insertion_point(field_set:MumbleProto.CodecVersion.alpha)
}

// required int32 beta = 2;
inline bool CodecVersion::has_beta() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CodecVersion::clear_beta() {
  beta_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::google::protobuf::int32 CodecVersion::beta() const {
  // @@protoc_insertion_point(field_get:MumbleProto.CodecVersion.beta)
  return beta_;
}
inline void CodecVersion::set_beta(::google::protobuf::int32 value) {
  _has_bits_[0] |= 0x00000002u;
  beta_ = value;
  // @@protoc_insertion_point(field_set:MumbleProto.CodecVersion.beta)
}

// required bool prefer_alpha = 3 [default = true];
inline bool CodecVersion::has_prefer_alpha() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CodecVersion::clear_prefer_alpha() {
  prefer_alpha_ = true;
  _has_bits_[0] &= ~0x00000008u;
}
inline bool CodecVersion::prefer_alpha() const {
  // @@protoc_insertion_point(field_get:MumbleProto.CodecVersion.prefer_alpha)
  return prefer_alpha_;
}
inline void CodecVersion::set_prefer_alpha(bool value) {
  _has_bits_[0] |= 0x00000008u;
  prefer_alpha_ = value;
  // @@protoc_insertion_point(field_set:MumbleProto.CodecVersion.prefer_alpha)
}

// optional bool opus = 4 [default = false];
inline bool CodecVersion::has_opus() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CodecVersion::clear_opus() {
  opus_ = false;
  _has_bits_[0] &= ~0x00000004u;
}
inline bool CodecVersion::opus() const {
  // @@protoc_insertion_point(field_get:MumbleProto.CodecVersion.opus)
  return opus_;
}
inline void CodecVersion::set_opus(bool value) {
  _has_bits_[0] |= 0x00000004u;
  opus_ = value;
  // @@protoc_insertion_point(field_set:MumbleProto.CodecVersion.opus)
}

// -------------------------------------------------------------------

// UserStats_Stats

// optional uint32 good = 1;
inline bool UserStats_Stats::has_good() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UserStats_Stats::clear_good() {
  good_ = 0u;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::google::protobuf::uint32 UserStats_Stats::good() const {
  // @@protoc_insertion_point(field_get:MumbleProto.UserStats.Stats.good)
  return good_;
}
inline void UserStats_Stats::set_good(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000001u;
  good_ = value;
  // @@protoc_insertion_point(field_set:MumbleProto.UserStats.Stats.good)
}

// optional uint32 late = 2;
inline bool UserStats_Stats::has_late() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UserStats_Stats::clear_late() {
  late_ = 0u;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::google::protobuf::uint32 UserStats_Stats::late() const {
  // @@protoc_insertion_point(field_get:MumbleProto.UserStats.Stats.late)
  return late_;
}
inline void UserStats_Stats::set_late(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000002u;
  late_ = value;
  // @@protoc_insertion_point(field_set:MumbleProto.UserStats.Stats.late)
}

// optional uint32 lost = 3;
inline bool UserStats_Stats::has_lost() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void UserStats_Stats::clear_lost() {
  lost_ = 0u;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::google::protobuf::uint32 UserStats_Stats::lost() const {
  // @@protoc_insertion_point(field_get:MumbleProto.UserStats.Stats.lost)
  return lost_;
}
inline void UserStats_Stats::set_lost(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000004u;
  lost_ = value;
  // @@protoc_insertion_point(field_set:MumbleProto.UserStats.Stats.lost)
}

// optional uint32 resync = 4;
inline bool UserStats_Stats::has_resync() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void UserStats_Stats::clear_resync() {
  resync_ = 0u;
  _has_bits_[0] &= ~0x00000008u;
}
inline ::google::protobuf::uint32 UserStats_Stats::resync() const {
  // @@protoc_insertion_point(field_get:MumbleProto.UserStats.Stats.resync)
  return resync_;
}
inline void UserStats_Stats::set_resync(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000008u;
  resync_ = value;
  // @@protoc_insertion_point(field_set:MumbleProto.UserStats.Stats.resync)
}

// -------------------------------------------------------------------

// UserStats

// optional uint32 session = 1;
inline bool UserStats::has_session() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void UserStats::clear_session() {
  session_ = 0u;
  _has_bits_[0] &= ~0x00000010u;
}
inline ::google::protobuf::uint32 UserStats::session() const {
  // @@protoc_insertion_point(field_get:MumbleProto.UserStats.session)
  return session_;
}
inline void UserStats::set_session(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000010u;
  session_ = value;
  // @@protoc_insertion_point(field_set:MumbleProto.UserStats.session)
}

// optional bool stats_only = 2 [default = false];
inline bool UserStats::has_stats_only() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void UserStats::clear_stats_only() {
  stats_only_ = false;
  _has_bits_[0] &= ~0x00000800u;
}
inline bool UserStats::stats_only() const {
  // @@protoc_insertion_point(field_get:MumbleProto.UserStats.stats_only)
  return stats_only_;
}
inline void UserStats::set_stats_only(bool value) {
  _has_bits_[0] |= 0x00000800u;
  stats_only_ = value;
  // @@protoc_insertion_point(field_set:MumbleProto.UserStats.stats_only)
}

// repeated bytes certificates = 3;
inline int UserStats::certificates_size() const {
  return certificates_.size();
}
inline void UserStats::clear_certificates() {
  certificates_.Clear();
}
inline const ::std::string& UserStats::certificates(int index) const {
  // @@protoc_insertion_point(field_get:MumbleProto.UserStats.certificates)
  return certificates_.Get(index);
}
inline ::std::string* UserStats::mutable_certificates(int index) {
  // @@protoc_insertion_point(field_mutable:MumbleProto.UserStats.certificates)
  return certificates_.Mutable(index);
}
inline void UserStats::set_certificates(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:MumbleProto.UserStats.certificates)
  certificates_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void UserStats::set_certificates(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:MumbleProto.UserStats.certificates)
  certificates_.Mutable(index)->assign(std::move(value));
}
#endif
inline void UserStats::set_certificates(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  certificates_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:MumbleProto.UserStats.certificates)
}
inline void UserStats::set_certificates(int index, const void* value, size_t size) {
  certificates_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:MumbleProto.UserStats.certificates)
}
inline ::std::string* UserStats::add_certificates() {
  // @@protoc_insertion_point(field_add_mutable:MumbleProto.UserStats.certificates)
  return certificates_.Add();
}
inline void UserStats::add_certificates(const ::std::string& value) {
  certificates_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:MumbleProto.UserStats.certificates)
}
#if LANG_CXX11
inline void UserStats::add_certificates(::std::string&& value) {
  certificates_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:MumbleProto.UserStats.certificates)
}
#endif
inline void UserStats::add_certificates(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  certificates_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:MumbleProto.UserStats.certificates)
}
inline void UserStats::add_certificates(const void* value, size_t size) {
  certificates_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:MumbleProto.UserStats.certificates)
}
inline const ::google::protobuf::RepeatedPtrField<::std::string>&
UserStats::certificates() const {
  // @@protoc_insertion_point(field_list:MumbleProto.UserStats.certificates)
  return certificates_;
}
inline ::google::protobuf::RepeatedPtrField<::std::string>*
UserStats::mutable_certificates() {
  // @@protoc_insertion_point(field_mutable_list:MumbleProto.UserStats.certificates)
  return &certificates_;
}

// optional .MumbleProto.UserStats.Stats from_client = 4;
inline bool UserStats::has_from_client() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UserStats::clear_from_client() {
  if (from_client_ != nullptr) from_client_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::MumbleProto::UserStats_Stats& UserStats::from_client() const {
  const ::MumbleProto::UserStats_Stats* p = from_client_;
  // @@protoc_insertion_point(field_get:MumbleProto.UserStats.from_client)
  return p != nullptr ? *p : *reinterpret_cast<const ::MumbleProto::UserStats_Stats*>(
      &::MumbleProto::_UserStats_Stats_default_instance_);
}
inline ::MumbleProto::UserStats_Stats* UserStats::release_from_client() {
  // @@protoc_insertion_point(field_release:MumbleProto.UserStats.from_client)
  _has_bits_[0] &= ~0x00000002u;
  ::MumbleProto::UserStats_Stats* temp = from_client_;
  from_client_ = nullptr;
  return temp;
}
inline ::MumbleProto::UserStats_Stats* UserStats::mutable_from_client() {
  _has_bits_[0] |= 0x00000002u;
  if (from_client_ == nullptr) {
    auto* p = CreateMaybeMessage<::MumbleProto::UserStats_Stats>(GetArenaNoVirtual());
    from_client_ = p;
  }
  // @@protoc_insertion_point(field_mutable:MumbleProto.UserStats.from_client)
  return from_client_;
}
inline void UserStats::set_allocated_from_client(::MumbleProto::UserStats_Stats* from_client) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete from_client_;
  }
  if (from_client) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      from_client = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, from_client, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  from_client_ = from_client;
  // @@protoc_insertion_point(field_set_allocated:MumbleProto.UserStats.from_client)
}

// optional .MumbleProto.UserStats.Stats from_server = 5;
inline bool UserStats::has_from_server() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void UserStats::clear_from_server() {
  if (from_server_ != nullptr) from_server_->Clear();
  _has_bits_[0] &= ~0x00000004u;
}
inline const ::MumbleProto::UserStats_Stats& UserStats::from_server() const {
  const ::MumbleProto::UserStats_Stats* p = from_server_;
  // @@protoc_insertion_point(field_get:MumbleProto.UserStats.from_server)
  return p != nullptr ? *p : *reinterpret_cast<const ::MumbleProto::UserStats_Stats*>(
      &::MumbleProto::_UserStats_Stats_default_instance_);
}
inline ::MumbleProto::UserStats_Stats* UserStats::release_from_server() {
  // @@protoc_insertion_point(field_release:MumbleProto.UserStats.from_server)
  _has_bits_[0] &= ~0x00000004u;
  ::MumbleProto::UserStats_Stats* temp = from_server_;
  from_server_ = nullptr;
  return temp;
}
inline ::MumbleProto::UserStats_Stats* UserStats::mutable_from_server() {
  _has_bits_[0] |= 0x00000004u;
  if (from_server_ == nullptr) {
    auto* p = CreateMaybeMessage<::MumbleProto::UserStats_Stats>(GetArenaNoVirtual());
    from_server_ = p;
  }
  // @@protoc_insertion_point(field_mutable:MumbleProto.UserStats.from_server)
  return from_server_;
}
inline void UserStats::set_allocated_from_server(::MumbleProto::UserStats_Stats* from_server) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete from_server_;
  }
  if (from_server) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      from_server = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, from_server, submessage_arena);
    }
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  from_server_ = from_server;
  // @@protoc_insertion_point(field_set_allocated:MumbleProto.UserStats.from_server)
}

// optional uint32 udp_packets = 6;
inline bool UserStats::has_udp_packets() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void UserStats::clear_udp_packets() {
  udp_packets_ = 0u;
  _has_bits_[0] &= ~0x00000020u;
}
inline ::google::protobuf::uint32 UserStats::udp_packets() const {
  // @@protoc_insertion_point(field_get:MumbleProto.UserStats.udp_packets)
  return udp_packets_;
}
inline void UserStats::set_udp_packets(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000020u;
  udp_packets_ = value;
  // @@protoc_insertion_point(field_set:MumbleProto.UserStats.udp_packets)
}

// optional uint32 tcp_packets = 7;
inline bool UserStats::has_tcp_packets() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void UserStats::clear_tcp_packets() {
  tcp_packets_ = 0u;
  _has_bits_[0] &= ~0x00000040u;
}
inline ::google::protobuf::uint32 UserStats::tcp_packets() const {
  // @@protoc_insertion_point(field_get:MumbleProto.UserStats.tcp_packets)
  return tcp_packets_;
}
inline void UserStats::set_tcp_packets(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000040u;
  tcp_packets_ = value;
  // @@protoc_insertion_point(field_set:MumbleProto.UserStats.tcp_packets)
}

// optional float udp_ping_avg = 8;
inline bool UserStats::has_udp_ping_avg() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void UserStats::clear_udp_ping_avg() {
  udp_ping_avg_ = 0;
  _has_bits_[0] &= ~0x00000080u;
}
inline float UserStats::udp_ping_avg() const {
  // @@protoc_insertion_point(field_get:MumbleProto.UserStats.udp_ping_avg)
  return udp_ping_avg_;
}
inline void UserStats::set_udp_ping_avg(float value) {
  _has_bits_[0] |= 0x00000080u;
  udp_ping_avg_ = value;
  // @@protoc_insertion_point(field_set:MumbleProto.UserStats.udp_ping_avg)
}

// optional float udp_ping_var = 9;
inline bool UserStats::has_udp_ping_var() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void UserStats::clear_udp_ping_var() {
  udp_ping_var_ = 0;
  _has_bits_[0] &= ~0x00000100u;
}
inline float UserStats::udp_ping_var() const {
  // @@protoc_insertion_point(field_get:MumbleProto.UserStats.udp_ping_var)
  return udp_ping_var_;
}
inline void UserStats::set_udp_ping_var(float value) {
  _has_bits_[0] |= 0x00000100u;
  udp_ping_var_ = value;
  // @@protoc_insertion_point(field_set:MumbleProto.UserStats.udp_ping_var)
}

// optional float tcp_ping_avg = 10;
inline bool UserStats::has_tcp_ping_avg() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void UserStats::clear_tcp_ping_avg() {
  tcp_ping_avg_ = 0;
  _has_bits_[0] &= ~0x00000200u;
}
inline float UserStats::tcp_ping_avg() const {
  // @@protoc_insertion_point(field_get:MumbleProto.UserStats.tcp_ping_avg)
  return tcp_ping_avg_;
}
inline void UserStats::set_tcp_ping_avg(float value) {
  _has_bits_[0] |= 0x00000200u;
  tcp_ping_avg_ = value;
  // @@protoc_insertion_point(field_set:MumbleProto.UserStats.tcp_ping_avg)
}

// optional float tcp_ping_var = 11;
inline bool UserStats::has_tcp_ping_var() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void UserStats::clear_tcp_ping_var() {
  tcp_ping_var_ = 0;
  _has_bits_[0] &= ~0x00000400u;
}
inline float UserStats::tcp_ping_var() const {
  // @@protoc_insertion_point(field_get:MumbleProto.UserStats.tcp_ping_var)
  return tcp_ping_var_;
}
inline void UserStats::set_tcp_ping_var(float value) {
  _has_bits_[0] |= 0x00000400u;
  tcp_ping_var_ = value;
  // @@protoc_insertion_point(field_set:MumbleProto.UserStats.tcp_ping_var)
}

// optional .MumbleProto.Version version = 12;
inline bool UserStats::has_version() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void UserStats::clear_version() {
  if (version_ != nullptr) version_->Clear();
  _has_bits_[0] &= ~0x00000008u;
}
inline const ::MumbleProto::Version& UserStats::version() const {
  const ::MumbleProto::Version* p = version_;
  // @@protoc_insertion_point(field_get:MumbleProto.UserStats.version)
  return p != nullptr ? *p : *reinterpret_cast<const ::MumbleProto::Version*>(
      &::MumbleProto::_Version_default_instance_);
}
inline ::MumbleProto::Version* UserStats::release_version() {
  // @@protoc_insertion_point(field_release:MumbleProto.UserStats.version)
  _has_bits_[0] &= ~0x00000008u;
  ::MumbleProto::Version* temp = version_;
  version_ = nullptr;
  return temp;
}
inline ::MumbleProto::Version* UserStats::mutable_version() {
  _has_bits_[0] |= 0x00000008u;
  if (version_ == nullptr) {
    auto* p = CreateMaybeMessage<::MumbleProto::Version>(GetArenaNoVirtual());
    version_ = p;
  }
  // @@protoc_insertion_point(field_mutable:MumbleProto.UserStats.version)
  return version_;
}
inline void UserStats::set_allocated_version(::MumbleProto::Version* version) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete version_;
  }
  if (version) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      version = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, version, submessage_arena);
    }
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  version_ = version;
  // @@protoc_insertion_point(field_set_allocated:MumbleProto.UserStats.version)
}

// repeated int32 celt_versions = 13;
inline int UserStats::celt_versions_size() const {
  return celt_versions_.size();
}
inline void UserStats::clear_celt_versions() {
  celt_versions_.Clear();
}
inline ::google::protobuf::int32 UserStats::celt_versions(int index) const {
  // @@protoc_insertion_point(field_get:MumbleProto.UserStats.celt_versions)
  return celt_versions_.Get(index);
}
inline void UserStats::set_celt_versions(int index, ::google::protobuf::int32 value) {
  celt_versions_.Set(index, value);
  // @@protoc_insertion_point(field_set:MumbleProto.UserStats.celt_versions)
}
inline void UserStats::add_celt_versions(::google::protobuf::int32 value) {
  celt_versions_.Add(value);
  // @@protoc_insertion_point(field_add:MumbleProto.UserStats.celt_versions)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
UserStats::celt_versions() const {
  // @@protoc_insertion_point(field_list:MumbleProto.UserStats.celt_versions)
  return celt_versions_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
UserStats::mutable_celt_versions() {
  // @@protoc_insertion_point(field_mutable_list:MumbleProto.UserStats.celt_versions)
  return &celt_versions_;
}

// optional bytes address = 14;
inline bool UserStats::has_address() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UserStats::clear_address() {
  address_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::std::string& UserStats::address() const {
  // @@protoc_insertion_point(field_get:MumbleProto.UserStats.address)
  return address_.GetNoArena();
}
inline void UserStats::set_address(const ::std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:MumbleProto.UserStats.address)
}
#if LANG_CXX11
inline void UserStats::set_address(::std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  address_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:MumbleProto.UserStats.address)
}
#endif
inline void UserStats::set_address(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:MumbleProto.UserStats.address)
}
inline void UserStats::set_address(const void* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:MumbleProto.UserStats.address)
}
inline ::std::string* UserStats::mutable_address() {
  _has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_mutable:MumbleProto.UserStats.address)
  return address_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* UserStats::release_address() {
  // @@protoc_insertion_point(field_release:MumbleProto.UserStats.address)
  if (!has_address()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return address_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void UserStats::set_allocated_address(::std::string* address) {
  if (address != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  address_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), address);
  // @@protoc_insertion_point(field_set_allocated:MumbleProto.UserStats.address)
}

// optional uint32 bandwidth = 15;
inline bool UserStats::has_bandwidth() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void UserStats::clear_bandwidth() {
  bandwidth_ = 0u;
  _has_bits_[0] &= ~0x00004000u;
}
inline ::google::protobuf::uint32 UserStats::bandwidth() const {
  // @@protoc_insertion_point(field_get:MumbleProto.UserStats.bandwidth)
  return bandwidth_;
}
inline void UserStats::set_bandwidth(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00004000u;
  bandwidth_ = value;
  // @@protoc_insertion_point(field_set:MumbleProto.UserStats.bandwidth)
}

// optional uint32 onlinesecs = 16;
inline bool UserStats::has_onlinesecs() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void UserStats::clear_onlinesecs() {
  onlinesecs_ = 0u;
  _has_bits_[0] &= ~0x00008000u;
}
inline ::google::protobuf::uint32 UserStats::onlinesecs() const {
  // @@protoc_insertion_point(field_get:MumbleProto.UserStats.onlinesecs)
  return onlinesecs_;
}
inline void UserStats::set_onlinesecs(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00008000u;
  onlinesecs_ = value;
  // @@protoc_insertion_point(field_set:MumbleProto.UserStats.onlinesecs)
}

// optional uint32 idlesecs = 17;
inline bool UserStats::has_idlesecs() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void UserStats::clear_idlesecs() {
  idlesecs_ = 0u;
  _has_bits_[0] &= ~0x00010000u;
}
inline ::google::protobuf::uint32 UserStats::idlesecs() const {
  // @@protoc_insertion_point(field_get:MumbleProto.UserStats.idlesecs)
  return idlesecs_;
}
inline void UserStats::set_idlesecs(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00010000u;
  idlesecs_ = value;
  // @@protoc_insertion_point(field_set:MumbleProto.UserStats.idlesecs)
}

// optional bool strong_certificate = 18 [default = false];
inline bool UserStats::has_strong_certificate() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void UserStats::clear_strong_certificate() {
  strong_certificate_ = false;
  _has_bits_[0] &= ~0x00001000u;
}
inline bool UserStats::strong_certificate() const {
  // @@protoc_insertion_point(field_get:MumbleProto.UserStats.strong_certificate)
  return strong_certificate_;
}
inline void UserStats::set_strong_certificate(bool value) {
  _has_bits_[0] |= 0x00001000u;
  strong_certificate_ = value;
  // @@protoc_insertion_point(field_set:MumbleProto.UserStats.strong_certificate)
}

// optional bool opus = 19 [default = false];
inline bool UserStats::has_opus() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void UserStats::clear_opus() {
  opus_ = false;
  _has_bits_[0] &= ~0x00002000u;
}
inline bool UserStats::opus() const {
  // @@protoc_insertion_point(field_get:MumbleProto.UserStats.opus)
  return opus_;
}
inline void UserStats::set_opus(bool value) {
  _has_bits_[0] |= 0x00002000u;
  opus_ = value;
  // @@protoc_insertion_point(field_set:MumbleProto.UserStats.opus)
}

// -------------------------------------------------------------------

// SuggestConfig

// optional uint32 version = 1;
inline bool SuggestConfig::has_version() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SuggestConfig::clear_version() {
  version_ = 0u;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::google::protobuf::uint32 SuggestConfig::version() const {
  // @@protoc_insertion_point(field_get:MumbleProto.SuggestConfig.version)
  return version_;
}
inline void SuggestConfig::set_version(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000001u;
  version_ = value;
  // @@protoc_insertion_point(field_set:MumbleProto.SuggestConfig.version)
}

// optional bool positional = 2;
inline bool SuggestConfig::has_positional() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SuggestConfig::clear_positional() {
  positional_ = false;
  _has_bits_[0] &= ~0x00000002u;
}
inline bool SuggestConfig::positional() const {
  // @@protoc_insertion_point(field_get:MumbleProto.SuggestConfig.positional)
  return positional_;
}
inline void SuggestConfig::set_positional(bool value) {
  _has_bits_[0] |= 0x00000002u;
  positional_ = value;
  // @@protoc_insertion_point(field_set:MumbleProto.SuggestConfig.positional)
}

// optional bool push_to_talk = 3;
inline bool SuggestConfig::has_push_to_talk() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SuggestConfig::clear_push_to_talk() {
  push_to_talk_ = false;
  _has_bits_[0] &= ~0x00000004u;
}
inline bool SuggestConfig::push_to_talk() const {
  // @@protoc_insertion_point(field_get:MumbleProto.SuggestConfig.push_to_talk)
  return push_to_talk_;
}
inline void SuggestConfig::set_push_to_talk(bool value) {
  _has_bits_[0] |= 0x00000004u;
  push_to_talk_ = value;
  // @@protoc_insertion_point(field_set:MumbleProto.SuggestConfig.push_to_talk)
}

// -------------------------------------------------------------------

// RequestBlob

// repeated uint32 session_texture = 1;
inline int RequestBlob::session_texture_size() const {
  return session_texture_.size();
}
inline void RequestBlob::clear_session_texture() {
  session_texture_.Clear();
}
inline ::google::protobuf::uint32 RequestBlob::session_texture(int index) const {
  // @@protoc_insertion_point(field_get:MumbleProto.RequestBlob.session_texture)
  return session_texture_.Get(index);
}
inline void RequestBlob::set_session_texture(int index, ::google::protobuf::uint32 value) {
  session_texture_.Set(index, value);
  // @@protoc_insertion_point(field_set:MumbleProto.RequestBlob.session_texture)
}
inline void RequestBlob::add_session_texture(::google::protobuf::uint32 value) {
  session_texture_.Add(value);
  // @@protoc_insertion_point(field_add:MumbleProto.RequestBlob.session_texture)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
RequestBlob::session_texture() const {
  // @@protoc_insertion_point(field_list:MumbleProto.RequestBlob.session_texture)
  return session_texture_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
RequestBlob::mutable_session_texture() {
  // @@protoc_insertion_point(field_mutable_list:MumbleProto.RequestBlob.session_texture)
  return &session_texture_;
}

// repeated uint32 session_comment = 2;
inline int RequestBlob::session_comment_size() const {
  return session_comment_.size();
}
inline void RequestBlob::clear_session_comment() {
  session_comment_.Clear();
}
inline ::google::protobuf::uint32 RequestBlob::session_comment(int index) const {
  // @@protoc_insertion_point(field_get:MumbleProto.RequestBlob.session_comment)
  return session_comment_.Get(index);
}
inline void RequestBlob::set_session_comment(int index, ::google::protobuf::uint32 value) {
  session_comment_.Set(index, value);
  // @@protoc_insertion_point(field_set:MumbleProto.RequestBlob.session_comment)
}
inline void RequestBlob::add_session_comment(::google::protobuf::uint32 value) {
  session_comment_.Add(value);
  // @@protoc_insertion_point(field_add:MumbleProto.RequestBlob.session_comment)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
RequestBlob::session_comment() const {
  // @@protoc_insertion_point(field_list:MumbleProto.RequestBlob.session_comment)
  return session_comment_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
RequestBlob::mutable_session_comment() {
  // @@protoc_insertion_point(field_mutable_list:MumbleProto.RequestBlob.session_comment)
  return &session_comment_;
}

// repeated uint32 channel_description = 3;
inline int RequestBlob::channel_description_size() const {
  return channel_description_.size();
}
inline void RequestBlob::clear_channel_description() {
  channel_description_.Clear();
}
inline ::google::protobuf::uint32 RequestBlob::channel_description(int index) const {
  // @@protoc_insertion_point(field_get:MumbleProto.RequestBlob.channel_description)
  return channel_description_.Get(index);
}
inline void RequestBlob::set_channel_description(int index, ::google::protobuf::uint32 value) {
  channel_description_.Set(index, value);
  // @@protoc_insertion_point(field_set:MumbleProto.RequestBlob.channel_description)
}
inline void RequestBlob::add_channel_description(::google::protobuf::uint32 value) {
  channel_description_.Add(value);
  // @@protoc_insertion_point(field_add:MumbleProto.RequestBlob.channel_description)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
RequestBlob::channel_description() const {
  // @@protoc_insertion_point(field_list:MumbleProto.RequestBlob.channel_description)
  return channel_description_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
RequestBlob::mutable_channel_description() {
  // @@protoc_insertion_point(field_mutable_list:MumbleProto.RequestBlob.channel_description)
  return &channel_description_;
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace MumbleProto

namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::MumbleProto::Reject_RejectType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::MumbleProto::Reject_RejectType>() {
  return ::MumbleProto::Reject_RejectType_descriptor();
}
template <> struct is_proto_enum< ::MumbleProto::PermissionDenied_DenyType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::MumbleProto::PermissionDenied_DenyType>() {
  return ::MumbleProto::PermissionDenied_DenyType_descriptor();
}
template <> struct is_proto_enum< ::MumbleProto::ContextActionModify_Context> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::MumbleProto::ContextActionModify_Context>() {
  return ::MumbleProto::ContextActionModify_Context_descriptor();
}
template <> struct is_proto_enum< ::MumbleProto::ContextActionModify_Operation> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::MumbleProto::ContextActionModify_Operation>() {
  return ::MumbleProto::ContextActionModify_Operation_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // PROTOBUF_INCLUDED_Mumble_2eproto
